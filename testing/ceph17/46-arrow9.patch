--- a/src/s3select/include/s3select_parquet_intrf.h
+++ b/src/s3select/include/s3select_parquet_intrf.h
@@ -164,7 +164,7 @@
   std::mutex lock_;
 
   // File descriptor
-  int fd_;
+  arrow::internal::FileDescriptor fd_;
 
   FileMode::type mode_;
 
@@ -202,7 +202,7 @@
     mode_ = write_only ? FileMode::WRITE : FileMode::READWRITE;
 
     if (!truncate) {
-      ARROW_ASSIGN_OR_RAISE(size_, ::arrow::internal::FileGetSize(fd_));
+      ARROW_ASSIGN_OR_RAISE(size_, ::arrow::internal::FileGetSize(fd_.fd()));
     } else {
       size_ = 0;
     }
@@ -222,7 +222,7 @@
     RETURN_NOT_OK(SetFileName(fd));
     is_open_ = true;
     mode_ = FileMode::WRITE;
-    fd_ = fd;
+    fd_ = arrow::internal::FileDescriptor{fd};
     return Status::OK();
   }
 
@@ -230,7 +230,7 @@
     RETURN_NOT_OK(SetFileName(path));
 
     ARROW_ASSIGN_OR_RAISE(fd_, ::arrow::internal::FileOpenReadable(file_name_));
-    ARROW_ASSIGN_OR_RAISE(size_, ::arrow::internal::FileGetSize(fd_));
+    ARROW_ASSIGN_OR_RAISE(size_, ::arrow::internal::FileGetSize(fd_.fd()));
 
     is_open_ = true;
     mode_ = FileMode::READ;
@@ -242,7 +242,7 @@
     RETURN_NOT_OK(SetFileName(fd));
     is_open_ = true;
     mode_ = FileMode::READ;
-    fd_ = fd;
+    fd_ = arrow::internal::FileDescriptor{fd};
     return Status::OK();
   }
 
@@ -258,9 +258,7 @@
       // Even if closing fails, the fd will likely be closed (perhaps it's
       // already closed).
       is_open_ = false;
-      int fd = fd_;
-      fd_ = -1;
-      RETURN_NOT_OK(::arrow::internal::FileClose(fd));
+      RETURN_NOT_OK(fd_.Close());
     }
     return Status::OK();
   }
@@ -266,7 +266,7 @@
   Result<int64_t> Read(int64_t nbytes, void* out) override {
     RETURN_NOT_OK(CheckClosed());
     RETURN_NOT_OK(CheckPositioned());
-    return ::arrow::internal::FileRead(fd_, reinterpret_cast<uint8_t*>(out), nbytes);
+    return ::arrow::internal::FileRead(fd_.fd(), reinterpret_cast<uint8_t*>(out), nbytes);
   }
 
   Result<int64_t> ReadAt(int64_t position, int64_t nbytes, void* out) override {
@@ -275,7 +275,7 @@
     // ReadAt() leaves the file position undefined, so require that we seek
     // before calling Read() or Write().
     need_seeking_.store(true);
-    return ::arrow::internal::FileReadAt(fd_, reinterpret_cast<uint8_t*>(out), position,
+    return ::arrow::internal::FileReadAt(fd_.fd(), reinterpret_cast<uint8_t*>(out), position,
                                          nbytes);
   }
 
@@ -284,7 +284,7 @@
     if (pos < 0) {
       return Status::Invalid("Invalid position");
     }
-    Status st = ::arrow::internal::FileSeek(fd_, pos);
+    Status st = ::arrow::internal::FileSeek(fd_.fd(), pos);
     if (st.ok()) {
       need_seeking_.store(false);
     }
@@ -295,7 +293,7 @@
 
   Result<int64_t> Tell() const override {
     RETURN_NOT_OK(CheckClosed());
-    return ::arrow::internal::FileTell(fd_);
+    return ::arrow::internal::FileTell(fd_.fd());
   }
 
   Status Write(const void* data, int64_t length) override {
@@ -306,7 +304,7 @@
     if (length < 0) {
       return Status::IOError("Length must be non-negative");
     }
-    return ::arrow::internal::FileWrite(fd_, reinterpret_cast<const uint8_t*>(data),
+    return ::arrow::internal::FileWrite(fd_.fd(), reinterpret_cast<const uint8_t*>(data),
                                         length);
   }
 
@@ -310,7 +310,7 @@
                                         length);
   }
 
-  int fd() const override { return fd_; }
+  int fd() const override { return fd_.fd(); }
 
   bool is_open() const override { return is_open_; }
 
@@ -345,7 +345,7 @@
   std::mutex lock_;
 
   // File descriptor
-  int fd_;
+  arrow::internal::FileDescriptor fd_;
 
   FileMode::type mode_;
 
@@ -411,7 +409,7 @@
       // already closed).
       is_open_ = false;
       //int fd = fd_;
-      fd_ = -1;
+      fd_.Close();
       //RETURN_NOT_OK(::arrow::internal::FileClose(fd));
     }
     return Status::OK();
@@ -421,7 +419,7 @@
     NOT_IMPLEMENT;
     RETURN_NOT_OK(CheckClosed());
     RETURN_NOT_OK(CheckPositioned());
-    return ::arrow::internal::FileRead(fd_, reinterpret_cast<uint8_t*>(out), nbytes);
+    return ::arrow::internal::FileRead(fd_.fd(), reinterpret_cast<uint8_t*>(out), nbytes);
   }
 
   Result<int64_t> ReadAt(int64_t position, int64_t nbytes, void* out) {
@@ -443,7 +443,7 @@
     return Status::OK();
   }
 
-  int fd() const { return fd_; }
+  int fd() const { return fd_.fd(); }
 
   bool is_open() const { return is_open_; }
 
@@ -467,7 +467,7 @@
   std::mutex lock_;
 
   // File descriptor
-  int fd_;
+  arrow::internal::FileDescriptor fd_;
 
   FileMode::type mode_;
 
@@ -609,7 +609,7 @@
     for (const auto& range : ranges) {
       RETURN_NOT_OK(internal::ValidateRange(range.offset, range.length));
 #if defined(POSIX_FADV_WILLNEED)
-      if (posix_fadvise(fd_, range.offset, range.length, POSIX_FADV_WILLNEED)) {
+      if (posix_fadvise(fd_.fd(), range.offset, range.length, POSIX_FADV_WILLNEED)) {
         return IOErrorFromErrno(errno, "posix_fadvise failed");
       }
 #elif defined(F_RDADVISE)  // macOS, BSD?
@@ -617,7 +617,7 @@
         off_t ra_offset;
         int ra_count;
       } radvisory{range.offset, static_cast<int>(range.length)};
-      if (radvisory.ra_count > 0 && fcntl(fd_, F_RDADVISE, &radvisory) == -1) {
+      if (radvisory.ra_count > 0 && fcntl(fd_.fd(), F_RDADVISE, &radvisory) == -1) {
         return IOErrorFromErrno(errno, "fcntl(fd, F_RDADVISE, ...) failed");
       }
 #endif
@@ -970,7 +970,7 @@
       CryptoContext ctx(col->has_dictionary_page(), row_group_ordinal_,
                         static_cast<int16_t>(i), meta_decryptor, data_decryptor);
       return PageReader::Open(stream, col->num_values(), col->compression(),
-                              properties_.memory_pool(), &ctx);
+                              false, properties_.memory_pool(), &ctx);
     }
 
     // The column is encrypted with its own key
@@ -985,7 +985,7 @@
     CryptoContext ctx(col->has_dictionary_page(), row_group_ordinal_,
                       static_cast<int16_t>(i), meta_decryptor, data_decryptor);
     return PageReader::Open(stream, col->num_values(), col->compression(),
-                            properties_.memory_pool(), &ctx);
+                            false, properties_.memory_pool(), &ctx);
   }
 
  private:
