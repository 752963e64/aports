From ba6be1043714458b29c4b37687d4f624ee421943 Mon Sep 17 00:00:00 2001
From: Christian Brauner <christian.brauner@ubuntu.com>
Date: Fri, 1 Oct 2021 10:27:58 +0200
Subject: [PATCH] lxd/checkfeature: check whether the kernel supports core
 scheduling

Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
---
 lxd/daemon.go                  |  2 +-
 lxd/include/syscall_wrappers.h | 78 ++++++++++++++++++++++++++++++++++
 lxd/main_checkfeature.go       | 39 +++++++++++++++++
 3 files changed, 118 insertions(+), 1 deletion(-)

diff --git a/lxd/daemon.go b/lxd/daemon.go
index df6e3adff..4155ea1e8 100644
--- a/lxd/daemon.go
+++ b/lxd/daemon.go
@@ -841,7 +841,7 @@ func (d *Daemon) init() error {
 		logger.Info(" - pidfds: no")
 	}
 
-	if d.os.LXCFeatures["core_scheduling"] {
+	if canUseCoreScheduling() && d.os.LXCFeatures["core_scheduling"] {
 		d.os.CoreScheduling = true
 		logger.Info(" - core scheduling: yes")
 	} else {
diff --git a/lxd/include/syscall_wrappers.h b/lxd/include/syscall_wrappers.h
index 25e56a5ce..4832b6637 100644
--- a/lxd/include/syscall_wrappers.h
+++ b/lxd/include/syscall_wrappers.h
@@ -6,6 +6,7 @@
 #endif
 #include <asm/unistd.h>
 #include <errno.h>
+#include <sys/prctl.h>
 #include <sys/syscall.h>
 #include <sys/types.h>
 #include <unistd.h>
@@ -49,4 +50,81 @@ static inline int move_mount(int from_dfd, const char *from_pathname, int to_dfd
 		       to_pathname, flags);
 }
 
+/* arg1 of prctl() */
+#ifndef PR_SCHED_CORE
+#define PR_SCHED_CORE 62
+#endif
+
+/* arg2 of prctl() */
+#ifndef PR_SCHED_CORE_GET
+#define PR_SCHED_CORE_GET 0
+#endif
+
+#ifndef PR_SCHED_CORE_CREATE
+#define PR_SCHED_CORE_CREATE 1 /* create unique core_sched cookie */
+#endif
+
+#ifndef PR_SCHED_CORE_SHARE_TO
+#define PR_SCHED_CORE_SHARE_TO 2 /* push core_sched cookie to pid */
+#endif
+
+#ifndef PR_SCHED_CORE_SHARE_FROM
+#define PR_SCHED_CORE_SHARE_FROM 3 /* pull core_sched cookie to pid */
+#endif
+
+#ifndef PR_SCHED_CORE_MAX
+#define PR_SCHED_CORE_MAX 4
+#endif
+
+/* arg3 of prctl() */
+#ifndef PR_SCHED_CORE_SCOPE_THREAD
+#define PR_SCHED_CORE_SCOPE_THREAD 0
+#endif
+
+#ifndef PR_SCHED_CORE_SCOPE_THREAD_GROUP
+#define PR_SCHED_CORE_SCOPE_THREAD_GROUP 1
+#endif
+
+#ifndef PR_SCHED_CORE_SCOPE_PROCESS_GROUP
+#define PR_SCHED_CORE_SCOPE_PROCESS_GROUP 2
+#endif
+
+#define INVALID_SCHED_CORE_COOKIE ((__u64)-1)
+
+static inline bool core_scheduling_cookie_valid(__u64 cookie)
+{
+	return (cookie > 0) && (cookie != INVALID_SCHED_CORE_COOKIE);
+}
+
+static inline __u64 core_scheduling_cookie_get(pid_t pid)
+{
+	__u64 cookie;
+	int ret;
+
+	ret = prctl(PR_SCHED_CORE, PR_SCHED_CORE_GET, pid,
+		    PR_SCHED_CORE_SCOPE_THREAD, (unsigned long)&cookie);
+	if (ret)
+		return INVALID_SCHED_CORE_COOKIE;
+
+	return cookie;
+}
+
+static inline int core_scheduling_cookie_create_threadgroup(pid_t pid)
+{
+	int ret;
+
+	ret = prctl(PR_SCHED_CORE, PR_SCHED_CORE_CREATE, pid,
+		    PR_SCHED_CORE_SCOPE_THREAD_GROUP, 0);
+	if (ret)
+		return -errno;
+
+	return 0;
+}
+
+static inline int core_scheduling_cookie_share_with(pid_t pid)
+{
+	return prctl(PR_SCHED_CORE, PR_SCHED_CORE_SHARE_FROM, pid,
+		     PR_SCHED_CORE_SCOPE_THREAD, 0);
+}
+
 #endif /* __LXD_SYSCALL_WRAPPER_H */
diff --git a/lxd/main_checkfeature.go b/lxd/main_checkfeature.go
index 0cc892071..a2c134da6 100644
--- a/lxd/main_checkfeature.go
+++ b/lxd/main_checkfeature.go
@@ -43,6 +43,7 @@ import (
 #include "include/syscall_numbers.h"
 #include "include/syscall_wrappers.h"
 
+__ro_after_init bool core_scheduling_aware = false;
 __ro_after_init bool close_range_aware = false;
 __ro_after_init bool tiocgptpeer_aware = false;
 __ro_after_init bool netnsid_aware = false;
@@ -502,6 +503,39 @@ static void is_close_range_aware(void)
 	close_range_aware = true;
 }
 
+static void is_core_scheduling_aware(void)
+{
+	int ret;
+	pid_t pid;
+
+	pid = fork();
+	if (pid < 0)
+		return;
+
+	if (pid == 0) {
+		pid_t pid_self;
+		__u64 core_sched_cookie;
+
+		pid_self = getpid();
+
+		ret = core_scheduling_cookie_create_threadgroup(pid_self);
+		if (ret)
+			_exit(EXIT_FAILURE);
+
+		core_sched_cookie = core_scheduling_cookie_get(pid_self);
+		if (!core_scheduling_cookie_valid(core_sched_cookie))
+			_exit(EXIT_FAILURE);
+
+		_exit(EXIT_SUCCESS);
+	}
+
+	ret = wait_for_pid(pid);
+	if (ret)
+		return;
+
+	core_scheduling_aware = true;
+}
+
 void checkfeature(void)
 {
 	__do_close int hostnetns_fd = -EBADF, newnetns_fd = -EBADF, pidfd = -EBADF;
@@ -512,6 +546,7 @@ void checkfeature(void)
 	is_seccomp_notify_aware();
 	is_tiocgptpeer_aware();
 	is_close_range_aware();
+	is_core_scheduling_aware();
 
 	if (pidfd >= 0)
 		pidfd_setns_aware = !setns(pidfd, CLONE_NEWNET);
@@ -604,3 +639,7 @@ func canUseCloseRange() bool {
 func canUsePidFdSetns() bool {
 	return bool(C.pidfd_setns_aware)
 }
+
+func canUseCoreScheduling() bool {
+	return bool(C.core_scheduling_aware)
+}
-- 
2.33.1

