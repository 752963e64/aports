From 7ca2b76e01a04787c2c5f308dea830937957dc20 Mon Sep 17 00:00:00 2001
From: Christian Brauner <christian.brauner@ubuntu.com>
Date: Wed, 6 Oct 2021 12:41:10 +0200
Subject: [PATCH] lxd: support core scheduling for container even without LXC
 library support

Let the forkcoresched hook be useable from a hook in LXD. This allows us
to turn on core scheduling for the main container workload even when the
LXC shared library doesn't support core scheduling.

Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
---
 lxd/instance/drivers/driver_common.go |  1 +
 lxd/instance/drivers/driver_lxc.go    | 11 +++++
 lxd/main_forkcoresched.go             | 26 ++++++++++-
 lxd/main_forkexec.go                  | 62 +++++++++++++++++++++++----
 4 files changed, 90 insertions(+), 10 deletions(-)

diff --git a/lxd/instance/drivers/driver_common.go b/lxd/instance/drivers/driver_common.go
index 13e79a49e..78281c255 100644
--- a/lxd/instance/drivers/driver_common.go
+++ b/lxd/instance/drivers/driver_common.go
@@ -971,6 +971,7 @@ func (d *common) setCoreSched(pids []int) error {
 
 	args := []string{
 		"forkcoresched",
+		"0",
 	}
 
 	for _, pid := range pids {
diff --git a/lxd/instance/drivers/driver_lxc.go b/lxd/instance/drivers/driver_lxc.go
index 0670a89c7..29c17f71b 100644
--- a/lxd/instance/drivers/driver_lxc.go
+++ b/lxd/instance/drivers/driver_lxc.go
@@ -744,6 +744,11 @@ func (d *lxc) initLXC(config bool) error {
 		if err != nil {
 			return err
 		}
+	} else if d.state.OS.CoreScheduling {
+		err = lxcSetConfigItem(cc, "lxc.hook.start-host", fmt.Sprintf("/proc/%d/exe forkcoresched 1", os.Getpid()))
+		if err != nil {
+			return err
+		}
 	}
 
 	// Allow for lightweight init
@@ -5686,6 +5691,12 @@ func (d *lxc) Exec(req api.InstanceExecPost, stdin *os.File, stdout *os.File, st
 		fmt.Sprintf("%d", req.Group),
 	}
 
+	if d.state.OS.CoreScheduling && !d.state.OS.ContainerCoreScheduling {
+		args = append(args, "1")
+	} else {
+		args = append(args, "0")
+	}
+
 	args = append(args, "--")
 	args = append(args, "env")
 	args = append(args, envSlice...)
diff --git a/lxd/main_forkcoresched.go b/lxd/main_forkcoresched.go
index ac2437056..6113a30fc 100644
--- a/lxd/main_forkcoresched.go
+++ b/lxd/main_forkcoresched.go
@@ -34,6 +34,8 @@ extern char* advance_arg(bool required);
 void forkcoresched(void)
 {
 	char *cur = NULL;
+	char *pidstr;
+	int hook;
 	int ret;
 	__u64 cookie;
 
@@ -56,7 +58,24 @@ void forkcoresched(void)
 	if (!core_scheduling_cookie_valid(cookie))
 		_exit(EXIT_FAILURE);
 
-	for (const char *pidstr = cur; pidstr; pidstr = advance_arg(false)) {
+	hook = atoi(cur);
+	switch (hook) {
+	case 0:
+		for (pidstr = cur; pidstr; pidstr = advance_arg(false)) {
+			ret = core_scheduling_cookie_share_to(atoi(pidstr));
+			if (ret)
+				_exit(EXIT_FAILURE);
+
+			cookie = core_scheduling_cookie_get(0);
+			if (!core_scheduling_cookie_valid(cookie))
+				_exit(EXIT_FAILURE);
+		}
+		break;
+	case 1:
+		pidstr = getenv("LXC_PID");
+		if (!pidstr)
+			_exit(EXIT_FAILURE);
+
 		ret = core_scheduling_cookie_share_to(atoi(pidstr));
 		if (ret)
 			_exit(EXIT_FAILURE);
@@ -64,6 +83,9 @@ void forkcoresched(void)
 		cookie = core_scheduling_cookie_get(0);
 		if (!core_scheduling_cookie_valid(cookie))
 			_exit(EXIT_FAILURE);
+		break;
+	default:
+		_exit(EXIT_FAILURE);
 	}
 
 	_exit(EXIT_SUCCESS);
@@ -78,7 +100,7 @@ type cmdForkcoresched struct {
 func (c *cmdForkcoresched) Command() *cobra.Command {
 	// Main subcommand
 	cmd := &cobra.Command{}
-	cmd.Use = "forkcoresched <PID> [...]"
+	cmd.Use = "forkcoresched <hook> <PID> [...]"
 	cmd.Short = "Create new core scheduling domain"
 	cmd.Long = `Description:
   Create new core scheduling domain
diff --git a/lxd/main_forkexec.go b/lxd/main_forkexec.go
index cfa4cd6bc..339d2202e 100644
--- a/lxd/main_forkexec.go
+++ b/lxd/main_forkexec.go
@@ -27,6 +27,7 @@ import (
 
 #include "include/macro.h"
 #include "include/memory_utils.h"
+#include "include/process_utils.h"
 #include "include/syscall_wrappers.h"
 #include <lxc/attach_options.h>
 #include <lxc/lxccontainer.h>
@@ -232,15 +233,17 @@ __attribute__ ((noinline)) static int __forkexec(void)
 	call_cleaner(lxc_container_put) struct lxc_container *c = NULL;
 	const char *config_path = NULL, *lxcpath = NULL, *name = NULL;
 	char *cwd = NULL;
+	pid_t init_pid;
 	lxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;
 	lxc_attach_command_t command = {
 		.program = NULL,
 	};
 	int fds_to_ignore[] = {EXEC_STDIN_FD, EXEC_STDOUT_FD, EXEC_STDERR_FD, EXEC_PIPE_FD};
 	int ret;
-	pid_t pid;
+	pid_t attached_pid;
 	uid_t uid;
 	gid_t gid;
+	int coresched;
 
 	if (geteuid() != 0)
 		return log_error(EXIT_FAILURE, "Error: forkexec requires root privileges");
@@ -260,6 +263,9 @@ __attribute__ ((noinline)) static int __forkexec(void)
 	gid = atoi(advance_arg(true));
 	if (gid < 0)
 		gid = (gid_t) - 1;
+	coresched = atoi(advance_arg(true));
+	if (coresched != 0 && coresched != 1)
+		_exit(EXIT_FAILURE);
 
 	for (char *arg = NULL, *section = NULL; (arg = advance_arg(false)); ) {
 		if (!strcmp(arg, "--") && (!section || strcmp(section, "cmd"))) {
@@ -328,19 +334,59 @@ __attribute__ ((noinline)) static int __forkexec(void)
 	command.program = argvp[0];
 	command.argv = argvp;
 
-	ret = c->attach(c, lxc_attach_run_command, &command, &attach_options, &pid);
+	ret = c->attach(c, lxc_attach_run_command, &command, &attach_options, &attached_pid);
 	if (ret < 0)
 		return EXIT_FAILURE;
 
-	if (!write_nointr(status_pipe, &pid, sizeof(pid))) {
+	if (!write_nointr(status_pipe, &attached_pid, sizeof(attached_pid))) {
 		// Kill the child just to be safe.
-		fprintf(stderr, "Failed to send pid %d of executing child to LXD. Killing child\n", pid);
-		kill(pid, SIGKILL);
+		fprintf(stderr, "Failed to send pid %d of executing child to LXD. Killing child\n", attached_pid);
+		kill(attached_pid, SIGKILL);
+		goto out_reap;
 	}
 
-	ret = wait_for_pid_status_nointr(pid);
+	if (coresched == 1) {
+		pid_t pid;
+
+		init_pid = c->init_pid(c);
+		if (init_pid < 0) {
+			kill(attached_pid, SIGKILL);
+			goto out_reap;
+		}
+
+		pid = vfork();
+		if (pid < 0) {
+			kill(attached_pid, SIGKILL);
+			goto out_reap;
+		}
+
+		if (pid == 0) {
+			__u64 cookie;
+
+			ret = core_scheduling_cookie_share_with(init_pid);
+			if (ret)
+				_exit(EXIT_FAILURE);
+
+			ret = core_scheduling_cookie_share_to(attached_pid);
+			if (ret)
+				_exit(EXIT_FAILURE);
+
+			cookie = core_scheduling_cookie_get(attached_pid);
+			if (!core_scheduling_cookie_valid(cookie))
+				_exit(EXIT_FAILURE);
+
+			_exit(EXIT_SUCCESS);
+		}
+
+		ret = wait_for_pid(pid);
+		if (ret)
+			kill(attached_pid, SIGKILL);
+	}
+
+out_reap:
+	ret = wait_for_pid_status_nointr(attached_pid);
 	if (ret < 0)
-		return log_error(EXIT_FAILURE, "Failed to wait for child process %d", pid);
+		return log_error(EXIT_FAILURE, "Failed to wait for child process %d", attached_pid);
 
 	if (WIFEXITED(ret))
 		return WEXITSTATUS(ret);
@@ -365,7 +411,7 @@ type cmdForkexec struct {
 func (c *cmdForkexec) Command() *cobra.Command {
 	// Main subcommand
 	cmd := &cobra.Command{}
-	cmd.Use = "forkexec <container name> <containers path> <config> <cwd> <uid> <gid> -- env [key=value...] -- cmd <args...>"
+	cmd.Use = "forkexec <container name> <containers path> <config> <cwd> <uid> <gid> <coresched> -- env [key=value...] -- cmd <args...>"
 	cmd.Short = "Execute a task inside the container"
 	cmd.Long = `Description:
   Execute a task inside the container
-- 
2.33.1

