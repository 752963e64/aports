From dfe460e3c3b331f543536d21a9082be26b147484 Mon Sep 17 00:00:00 2001
From: Craig Small <csmall@dropbear.xyz>
Date: Thu, 10 Aug 2023 21:18:38 +1000
Subject: [PATCH] ps: Fix possible buffer overflow in -C option

ps allocates memory using malloc(length of arg * len of struct).
In certain strange circumstances, the arg length could be very large
and the multiplecation will overflow, allocating a small amount of
memory.

Subsequent strncpy() will then write into unallocated memory.
The fix is to use calloc. It's slower but this is a one-time
allocation. Other malloc(x * y) calls have also been replaced
by calloc(x, y)

References:
 https://www.freelists.org/post/procps/ps-buffer-overflow-CVE-20234016
 https://nvd.nist.gov/vuln/detail/CVE-2023-4016
 https://gitlab.com/procps-ng/procps/-/issues/297
 https://bugs.debian.org/1042887

Signed-off-by: Craig Small <csmall@dropbear.xyz>
---
 ps/parser.c | 17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)

diff --git a/ps/parser.c b/ps/parser.c
index 4263a1f..eba0eca 100644
--- a/ps/parser.c
+++ b/ps/parser.c
@@ -53,6 +53,15 @@ static int thisarg;    /* index into ps_argv */
 static char *flagptr;  /* current location in ps_argv[thisarg] */
 static int force_bsd = 0;  /* set when normal parsing fails */
 
+static inline __attribute__((alloc_size(1, 2)))
+void *xcalloc2(const size_t nelems, const size_t size)
+{
+	void *ret = calloc(nelems, size);
+	if (!ret && size && nelems)
+		xerrx(EXIT_FAILURE, "cannot allocate %zu bytes", nelems*size);
+	return ret;
+}
+
 #define exclusive(x) if((ps_argc != 2) || strcmp(ps_argv[1],x)) \
   return _("the option is exclusive: " x)
 
@@ -184,7 +193,6 @@ static const char *parse_list(const char *arg, const char *(*parse_fn)(char *, s
   const char *err;       /* error code that could or did happen */
   /*** prepare to operate ***/
   node = malloc(sizeof(selection_node));
-  node->u = malloc(strlen(arg)*sizeof(sel_union)); /* waste is insignificant */
   node->n = 0;
   buf = strdup(arg);
   /*** sanity check and count items ***/
@@ -205,6 +213,7 @@ static const char *parse_list(const char *arg, const char *(*parse_fn)(char *, s
   } while (*++walk);
   if(need_item) goto parse_error;
   node->n = items;
+  node->u = xcalloc2(items, sizeof(sel_union));
   /*** actually parse the list ***/
   walk = buf;
   while(items--){
@@ -1031,15 +1040,15 @@ static const char *parse_trailing_pids(void){
   thisarg = ps_argc - 1;   /* we must be at the end now */
 
   pidnode = malloc(sizeof(selection_node));
-  pidnode->u = malloc(i*sizeof(sel_union)); /* waste is insignificant */
+  pidnode->u = xcalloc2(i, sizeof(sel_union)); /* waste is insignificant */
   pidnode->n = 0;
 
   grpnode = malloc(sizeof(selection_node));
-  grpnode->u = malloc(i*sizeof(sel_union)); /* waste is insignificant */
+  grpnode->u = xcalloc2(i,sizeof(sel_union)); /* waste is insignificant */
   grpnode->n = 0;
 
   sidnode = malloc(sizeof(selection_node));
-  sidnode->u = malloc(i*sizeof(sel_union)); /* waste is insignificant */
+  sidnode->u = xcalloc2(i, sizeof(sel_union)); /* waste is insignificant */
   sidnode->n = 0;
 
   while(i--){
-- 
2.38.5

