From 9d15bff89c1566e40569f689696d0393e7659df1 Mon Sep 17 00:00:00 2001
From: Michael Forney <mforney@mforney.org>
Date: Wed, 12 Feb 2020 23:19:05 -0800
Subject: [PATCH] deps: Treat missing depfile as empty for deps log

This matches ninja's behavior. When deps is not set, a missing
depfile causes the output to be dirty. When it is set, an empty set
of dependencies is recorded into the log.
---
 deps.c | 15 +++++++++------
 1 file changed, 9 insertions(+), 6 deletions(-)

diff --git a/deps.c b/deps.c
index 4eef994..1338919 100644
--- a/deps.c
+++ b/deps.c
@@ -296,7 +296,7 @@ depsclose(void)
 }
 
 static struct nodearray *
-depsparse(const char *name)
+depsparse(const char *name, bool allowmissing)
 {
 	static struct buffer buf;
 	static struct nodearray deps;
@@ -306,12 +306,15 @@ depsparse(const char *name)
 	int c, n;
 	bool sawcolon;
 
+	deps.len = 0;
 	f = fopen(name, "r");
-	if (!f)
+	if (!f) {
+		if (errno == ENOENT && allowmissing)
+			return &deps;
 		return NULL;
+	}
 	sawcolon = false;
 	buf.len = 0;
-	deps.len = 0;
 	c = getc(f);
 	for (;;) {
 		/* TODO: this parser needs to be rewritten to be made simpler */
@@ -438,9 +441,9 @@ depsload(struct edge *e)
 		depfile = edgevar(e, "depfile", false);
 		if (!depfile)
 			return;
-		deps = depsparse(depfile->s);
+		deps = depsparse(depfile->s, false);
 		if (buildopts.explain && !deps)
-			warn("explain %s: missing or invalid dep file", n->path->s);
+			warn("explain %s: missing or invalid depfile", n->path->s);
 	}
 	if (deps) {
 		edgeadddeps(e, deps->node, deps->len);
@@ -473,7 +476,7 @@ depsrecord(struct edge *e)
 		return;
 	}
 	out = e->out[0];
-	deps = depsparse(depfile->s);
+	deps = depsparse(depfile->s, true);
 	if (!buildopts.keepdepfile)
 		remove(depfile->s);
 	if (!deps)
