- New style scripts
- Internal gunzip (via lib) to speed up stuff, and avoid threads
	- mmap() if possible for reading

- Index/pkginfo reader: same field multiple times -> memleak

- Compress index and db files
- Repository support:
	- always keep local copy of index
	- index/package fetching from URLs
	- read from config file
	- cache .apks on USB stick when using network repo for reboot
- Installation of .APK files not in any repository

- Configfiles list in .PKGINFO
- Implement lbu stuff

- Error handling and rollback
- Dependency manipulation API: deletion, overwrite, check compatibility

- New user/group creation

- Non-trivial solution finder
	- Versioned dependencies
	- Conflicts
	- Provides

- Order removal of packages to honour dependencies
	- Create reverse dependencies for installed pkgs

- Remember counts for hash table creation

- Possibly create a token hash for package names, versions and licenses, etc.
- Calculate changeset installed-size change
- Option to not read fs entry cache

- Special packages?:
	- alpine-core: refuse to remove, installed at reboot?
	- alpine-sdk: to setup sdk environment

- Oldies:
  add, delete: read (pkgs+fs), modify DEPs, recalc+commit+write (pkgs+fs)
  fetch: read (pkgs), download remote packages
  fetch -u: read (pkgs), download indexes, write (pkgs)
  glob: read (pkgs), operate on package db
  info: read (pkgs+fs), mostly on package db, might need .apks
  version: read (pkgs), compare all installed pkg versions

- New:
  deps: show master dependencies
  index: new TARGET, scan packages, write INDEX (pkgs)
  upgrade: read TARGET, mark upgrade flags, recalculate, commit (pkgs+fs)

