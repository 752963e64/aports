From 816c36f9a1d24ac1b2a4c46d04cb2ca47d9c0a4e Mon Sep 17 00:00:00 2001
From: Luca Weiss <luca@z3ntu.xyz>
Date: Mon, 21 Oct 2019 21:05:28 +0200
Subject: [PATCH 2/2] qmi-device: detect rpmsg control ports

and adjust the path to check for smdpkt nodes
---
 src/libqmi-glib/qmi-utils.c | 16 ++++++++++++----
 1 file changed, 12 insertions(+), 4 deletions(-)

diff --git a/src/libqmi-glib/qmi-utils.c b/src/libqmi-glib/qmi-utils.c
index 6e46be9..7ef3b33 100644
--- a/src/libqmi-glib/qmi-utils.c
+++ b/src/libqmi-glib/qmi-utils.c
@@ -467,11 +467,19 @@ __qmi_utils_get_transport_type (const gchar  *path,
 
     driver = utils_get_driver (device_basename, &inner_error);
 
-    /* On Android systems we get access to the QMI control port through
-     * virtual smdcntl devices in the smdpkt subsystem. */
     if (!driver) {
-        path = g_strdup_printf ("/sys/devices/virtual/smdpkt/%s", device_basename);
-        if (g_file_test (path, G_FILE_TEST_EXISTS)) {
+        /* On Android systems we get access to the QMI control port through
+         * virtual smdcntl devices in the smdpkt subsystem. */
+        sysfs_path = g_strdup_printf ("/sys/class/smdpkt/%s", device_basename);
+        if (g_file_test (sysfs_path, G_FILE_TEST_EXISTS)) {
+            g_clear_error (&inner_error);
+            transport = __QMI_TRANSPORT_TYPE_QMUX;
+            goto out;
+        }
+        g_free (sysfs_path);
+        /* On mainline kernels this control port is provided by rpmsg */
+        sysfs_path = g_strdup_printf ("/sys/class/rpmsg/%s", device_basename);
+        if (g_file_test (sysfs_path, G_FILE_TEST_EXISTS)) {
             g_clear_error (&inner_error);
             transport = __QMI_TRANSPORT_TYPE_QMUX;
         }
-- 
2.26.0

