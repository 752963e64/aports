From 9cb95d1d461e6b06946535d3ec0d0c212a4c6b78 Mon Sep 17 00:00:00 2001
From: Arina Neshlyaeva <arina.neshlyaeva@intel.com>
Date: Tue, 6 Sep 2022 17:42:52 -0700
Subject: [PATCH] Return AddressInfo from AllocaInst

Modified to work
---
 src/builtins.cpp |   8 +-
 src/ctx.cpp      | 286 ++++++++++++++++++++++++-----------------------
 src/ctx.h        |  42 +++----
 src/expr.cpp     |  33 +++---
 src/func.cpp     |  56 +++++-----
 src/module.cpp   |  11 +-
 src/stmt.cpp     | 111 +++++++++---------
 src/sym.cpp      |   1 -
 src/sym.h        |   7 +-
 9 files changed, 282 insertions(+), 273 deletions(-)

diff --git a/src/builtins.cpp b/src/builtins.cpp
index c094d86..5aa963d 100644
--- a/src/builtins.cpp
+++ b/src/builtins.cpp
@@ -1085,7 +1085,7 @@ static void lDefineConstantInt(const char *name, int val, llvm::Module *module,
     llvm::Constant *linit = LLVMInt32(val);
     auto GV = new llvm::GlobalVariable(*module, ltype, true, llvm::GlobalValue::InternalLinkage, linit, name);
     dbg_sym.push_back(GV);
-    sym->storagePtr = GV;
+    sym->storageInfo = new AddressInfo(GV, GV->getValueType());
     symbolTable->AddVariable(sym);
 
     if (m->diBuilder != NULL) {
@@ -1095,7 +1095,7 @@ static void lDefineConstantInt(const char *name, int val, llvm::Module *module,
         // FIXME? DWARF says that this (and programIndex below) should
         // have the DW_AT_artifical attribute.  It's not clear if this
         // matters for anything though.
-        llvm::GlobalVariable *sym_GV_storagePtr = llvm::dyn_cast<llvm::GlobalVariable>(sym->storagePtr);
+        llvm::GlobalVariable *sym_GV_storagePtr = llvm::dyn_cast<llvm::GlobalVariable>(sym->storageInfo->getPointer());
         Assert(sym_GV_storagePtr);
         llvm::DIGlobalVariableExpression *var =
             m->diBuilder->createGlobalVariableExpression(cu, name, name, file, 0 /* line */, diType, true /* static */);
@@ -1140,14 +1140,14 @@ static void lDefineProgramIndex(llvm::Module *module, SymbolTable *symbolTable,
     auto GV =
         new llvm::GlobalVariable(*module, ltype, true, llvm::GlobalValue::InternalLinkage, linit, sym->name.c_str());
     dbg_sym.push_back(GV);
-    sym->storagePtr = GV;
+    sym->storageInfo = new AddressInfo(GV, GV->getValueType());
     symbolTable->AddVariable(sym);
 
     if (m->diBuilder != NULL) {
         llvm::DIFile *file = m->diCompileUnit->getFile();
         llvm::DICompileUnit *cu = m->diCompileUnit;
         llvm::DIType *diType = sym->type->GetDIType(file);
-        llvm::GlobalVariable *sym_GV_storagePtr = llvm::dyn_cast<llvm::GlobalVariable>(sym->storagePtr);
+        llvm::GlobalVariable *sym_GV_storagePtr = llvm::dyn_cast<llvm::GlobalVariable>(sym->storageInfo->getPointer());
         Assert(sym_GV_storagePtr);
         llvm::DIGlobalVariableExpression *var = m->diBuilder->createGlobalVariableExpression(
             cu, sym->name.c_str(), sym->name.c_str(), file, 0 /* line */, diType, false /* static */);
diff --git a/src/ctx.cpp b/src/ctx.cpp
index 772fea8..bfee20d 100644
--- a/src/ctx.cpp
+++ b/src/ctx.cpp
@@ -71,20 +71,20 @@ struct CFInfo {
     /** Returns a new instance of the structure that represents entering a
         loop. */
     static CFInfo *GetLoop(bool isUniform, bool isUniformEmulated, llvm::BasicBlock *breakTarget,
-                           llvm::BasicBlock *continueTarget, llvm::Value *savedBreakLanesPtr,
-                           llvm::Value *savedContinueLanesPtr, llvm::Value *savedMask,
+                           llvm::BasicBlock *continueTarget, AddressInfo *savedBreakLanesAddressInfo,
+                           AddressInfo *savedContinueLanesAddressInfo, llvm::Value *savedMask,
                            llvm::Value *savedBlockEntryMask);
 
     static CFInfo *GetForeach(bool isUniformEmulated, FunctionEmitContext::ForeachType ft,
                               llvm::BasicBlock *breakTarget, llvm::BasicBlock *continueTarget,
-                              llvm::Value *savedBreakLanesPtr, llvm::Value *savedContinueLanesPtr,
+                              AddressInfo *savedBreakLanesAddressInfo, AddressInfo *savedContinueLanesAddressInfo,
                               llvm::Value *savedMask, llvm::Value *savedBlockEntryMask);
 
     static CFInfo *GetSwitch(bool isUniform, bool isUniformEmulated, llvm::BasicBlock *breakTarget,
-                             llvm::BasicBlock *continueTarget, llvm::Value *savedBreakLanesPtr,
-                             llvm::Value *savedContinueLanesPtr, llvm::Value *savedMask,
+                             llvm::BasicBlock *continueTarget, AddressInfo *savedBreakLanesAddressInfo,
+                             AddressInfo *savedContinueLanesAddressInfo, llvm::Value *savedMask,
                              llvm::Value *savedBlockEntryMask, llvm::Value *switchExpr,
-                             llvm::Value *savedFallThroughMaskPtr, llvm::BasicBlock *bbDefault,
+                             AddressInfo *savedFallThroughMaskPtr, llvm::BasicBlock *bbDefault,
                              const std::vector<std::pair<int, llvm::BasicBlock *>> *bbCases,
                              const std::map<llvm::BasicBlock *, llvm::BasicBlock *> *bbNext, bool scUniform);
 
@@ -101,10 +101,10 @@ struct CFInfo {
     bool isUniform;
     bool isUniformEmulated;
     llvm::BasicBlock *savedBreakTarget, *savedContinueTarget;
-    llvm::Value *savedBreakLanesPtr, *savedContinueLanesPtr;
+    AddressInfo *savedBreakLanesAddressInfo, *savedContinueLanesAddressInfo;
     llvm::Value *savedMask, *savedBlockEntryMask;
     llvm::Value *savedSwitchExpr;
-    llvm::Value *savedSwitchFallThroughMaskPtr;
+    AddressInfo *savedSwitchFallThroughMaskAddressInfo;
     llvm::BasicBlock *savedDefaultBlock;
     const std::vector<std::pair<int, llvm::BasicBlock *>> *savedCaseBlocks;
     const std::map<llvm::BasicBlock *, llvm::BasicBlock *> *savedNextBlocks;
@@ -117,17 +117,17 @@ struct CFInfo {
         isUniform = uniformIf;
         isUniformEmulated = uniformEmu;
         savedBreakTarget = savedContinueTarget = NULL;
-        savedBreakLanesPtr = savedContinueLanesPtr = NULL;
+        savedBreakLanesAddressInfo = savedContinueLanesAddressInfo = NULL;
         savedMask = savedBlockEntryMask = sm;
         savedSwitchExpr = NULL;
-        savedSwitchFallThroughMaskPtr = NULL;
+        savedSwitchFallThroughMaskAddressInfo = NULL;
         savedDefaultBlock = NULL;
         savedCaseBlocks = NULL;
         savedNextBlocks = NULL;
         savedSwitchConditionWasUniform = false;
     }
-    CFInfo(CFType t, bool iu, bool uniformEmulated, llvm::BasicBlock *bt, llvm::BasicBlock *ct, llvm::Value *sb,
-           llvm::Value *sc, llvm::Value *sm, llvm::Value *lm, llvm::Value *sse = NULL, llvm::Value *ssftmp = NULL,
+    CFInfo(CFType t, bool iu, bool uniformEmulated, llvm::BasicBlock *bt, llvm::BasicBlock *ct, AddressInfo *sb,
+           AddressInfo *sc, llvm::Value *sm, llvm::Value *lm, llvm::Value *sse = NULL, AddressInfo *ssftmp = NULL,
            llvm::BasicBlock *bbd = NULL, const std::vector<std::pair<int, llvm::BasicBlock *>> *bbc = NULL,
            const std::map<llvm::BasicBlock *, llvm::BasicBlock *> *bbn = NULL, bool scu = false) {
         Assert(t == Loop || t == Switch);
@@ -136,18 +136,18 @@ struct CFInfo {
         isUniformEmulated = uniformEmulated;
         savedBreakTarget = bt;
         savedContinueTarget = ct;
-        savedBreakLanesPtr = sb;
-        savedContinueLanesPtr = sc;
+        savedBreakLanesAddressInfo = sb;
+        savedContinueLanesAddressInfo = sc;
         savedMask = sm;
         savedBlockEntryMask = lm;
         savedSwitchExpr = sse;
-        savedSwitchFallThroughMaskPtr = ssftmp;
+        savedSwitchFallThroughMaskAddressInfo = ssftmp;
         savedDefaultBlock = bbd;
         savedCaseBlocks = bbc;
         savedNextBlocks = bbn;
         savedSwitchConditionWasUniform = scu;
     }
-    CFInfo(CFType t, bool uniformEmulated, llvm::BasicBlock *bt, llvm::BasicBlock *ct, llvm::Value *sb, llvm::Value *sc,
+    CFInfo(CFType t, bool uniformEmulated, llvm::BasicBlock *bt, llvm::BasicBlock *ct, AddressInfo *sb, AddressInfo *sc,
            llvm::Value *sm, llvm::Value *lm) {
         Assert(t == ForeachRegular || t == ForeachActive || t == ForeachUnique);
         type = t;
@@ -155,12 +155,12 @@ struct CFInfo {
         isUniformEmulated = uniformEmulated;
         savedBreakTarget = bt;
         savedContinueTarget = ct;
-        savedBreakLanesPtr = sb;
-        savedContinueLanesPtr = sc;
+        savedBreakLanesAddressInfo = sb;
+        savedContinueLanesAddressInfo = sc;
         savedMask = sm;
         savedBlockEntryMask = lm;
         savedSwitchExpr = NULL;
-        savedSwitchFallThroughMaskPtr = NULL;
+        savedSwitchFallThroughMaskAddressInfo = NULL;
         savedDefaultBlock = NULL;
         savedCaseBlocks = NULL;
         savedNextBlocks = NULL;
@@ -173,15 +173,17 @@ CFInfo *CFInfo::GetIf(bool isUniform, bool isUniformEmulated, llvm::Value *saved
 }
 
 CFInfo *CFInfo::GetLoop(bool isUniform, bool isUniformEmulated, llvm::BasicBlock *breakTarget,
-                        llvm::BasicBlock *continueTarget, llvm::Value *savedBreakLanesPtr,
-                        llvm::Value *savedContinueLanesPtr, llvm::Value *savedMask, llvm::Value *savedBlockEntryMask) {
-    return new CFInfo(Loop, isUniform, isUniformEmulated, breakTarget, continueTarget, savedBreakLanesPtr,
-                      savedContinueLanesPtr, savedMask, savedBlockEntryMask);
+                        llvm::BasicBlock *continueTarget, AddressInfo *savedBreakLanesAddressInfo,
+                        AddressInfo *savedContinueLanesAddressInfo, llvm::Value *savedMask,
+                        llvm::Value *savedBlockEntryMask) {
+    return new CFInfo(Loop, isUniform, isUniformEmulated, breakTarget, continueTarget, savedBreakLanesAddressInfo,
+                      savedContinueLanesAddressInfo, savedMask, savedBlockEntryMask);
 }
 
 CFInfo *CFInfo::GetForeach(bool isUniformEmulated, FunctionEmitContext::ForeachType ft, llvm::BasicBlock *breakTarget,
-                           llvm::BasicBlock *continueTarget, llvm::Value *savedBreakLanesPtr,
-                           llvm::Value *savedContinueLanesPtr, llvm::Value *savedMask, llvm::Value *savedForeachMask) {
+                           llvm::BasicBlock *continueTarget, AddressInfo *savedBreakLanesAddressInfo,
+                           AddressInfo *savedContinueLanesAddressInfo, llvm::Value *savedMask,
+                           llvm::Value *savedForeachMask) {
     CFType cfType;
     switch (ft) {
     case FunctionEmitContext::FOREACH_REGULAR:
@@ -198,21 +200,21 @@ CFInfo *CFInfo::GetForeach(bool isUniformEmulated, FunctionEmitContext::ForeachT
         return NULL;
     }
 
-    return new CFInfo(cfType, isUniformEmulated, breakTarget, continueTarget, savedBreakLanesPtr, savedContinueLanesPtr,
-                      savedMask, savedForeachMask);
+    return new CFInfo(cfType, isUniformEmulated, breakTarget, continueTarget, savedBreakLanesAddressInfo,
+                      savedContinueLanesAddressInfo, savedMask, savedForeachMask);
 }
 
 CFInfo *CFInfo::GetSwitch(bool isUniform, bool isUniformEmulated, llvm::BasicBlock *breakTarget,
-                          llvm::BasicBlock *continueTarget, llvm::Value *savedBreakLanesPtr,
-                          llvm::Value *savedContinueLanesPtr, llvm::Value *savedMask, llvm::Value *savedBlockEntryMask,
-                          llvm::Value *savedSwitchExpr, llvm::Value *savedSwitchFallThroughMaskPtr,
-                          llvm::BasicBlock *savedDefaultBlock,
+                          llvm::BasicBlock *continueTarget, AddressInfo *savedBreakLanesAddressInfo,
+                          AddressInfo *savedContinueLanesAddressInfo, llvm::Value *savedMask,
+                          llvm::Value *savedBlockEntryMask, llvm::Value *savedSwitchExpr,
+                          AddressInfo *savedSwitchFallThroughMaskAddressInfo, llvm::BasicBlock *savedDefaultBlock,
                           const std::vector<std::pair<int, llvm::BasicBlock *>> *savedCases,
                           const std::map<llvm::BasicBlock *, llvm::BasicBlock *> *savedNext,
                           bool savedSwitchConditionUniform) {
-    return new CFInfo(Switch, isUniform, isUniformEmulated, breakTarget, continueTarget, savedBreakLanesPtr,
-                      savedContinueLanesPtr, savedMask, savedBlockEntryMask, savedSwitchExpr,
-                      savedSwitchFallThroughMaskPtr, savedDefaultBlock, savedCases, savedNext,
+    return new CFInfo(Switch, isUniform, isUniformEmulated, breakTarget, continueTarget, savedBreakLanesAddressInfo,
+                      savedContinueLanesAddressInfo, savedMask, savedBlockEntryMask, savedSwitchExpr,
+                      savedSwitchFallThroughMaskAddressInfo, savedDefaultBlock, savedCases, savedNext,
                       savedSwitchConditionUniform);
 }
 
@@ -253,8 +255,8 @@ FunctionEmitContext::FunctionEmitContext(Function *func, Symbol *funSym, llvm::F
 
     funcStartPos = funSym->pos;
 
-    internalMaskPointer = AllocaInst(LLVMTypes::MaskType, "internal_mask_memory");
-    StoreInst(LLVMMaskAllOn, internalMaskPointer);
+    internalMaskAddressInfo = AllocaInst(LLVMTypes::MaskType, "internal_mask_memory");
+    StoreInst(LLVMMaskAllOn, internalMaskAddressInfo->getPointer());
 
     // If the function doesn't have __mask in parameters, there is no need to
     // have function mask
@@ -262,15 +264,15 @@ FunctionEmitContext::FunctionEmitContext(Function *func, Symbol *funSym, llvm::F
          (lf->getFunctionType()->getNumParams() == func->GetType()->GetNumParameters())) ||
         (func->GetType()->isUnmasked) || func->GetType()->isTask) {
         functionMaskValue = NULL;
-        fullMaskPointer = NULL;
+        fullMaskAddressInfo = NULL;
     } else {
         functionMaskValue = LLVMMaskAllOn;
-        fullMaskPointer = AllocaInst(LLVMTypes::MaskType, "full_mask_memory");
-        StoreInst(LLVMMaskAllOn, fullMaskPointer);
+        fullMaskAddressInfo = AllocaInst(LLVMTypes::MaskType, "full_mask_memory");
+        StoreInst(LLVMMaskAllOn, fullMaskAddressInfo->getPointer());
     }
 
     blockEntryMask = NULL;
-    breakLanesPtr = continueLanesPtr = NULL;
+    breakLanesAddressInfo = continueLanesAddressInfo = NULL;
     breakTarget = continueTarget = NULL;
 
     switchExpr = NULL;
@@ -278,20 +280,20 @@ FunctionEmitContext::FunctionEmitContext(Function *func, Symbol *funSym, llvm::F
     defaultBlock = NULL;
     nextBlocks = NULL;
 
-    returnedLanesPtr = AllocaInst(LLVMTypes::MaskType, "returned_lanes_memory");
-    StoreInst(LLVMMaskAllOff, returnedLanesPtr);
+    returnedLanesAddressInfo = AllocaInst(LLVMTypes::MaskType, "returned_lanes_memory");
+    StoreInst(LLVMMaskAllOff, returnedLanesAddressInfo->getPointer());
 
     launchedTasks = false;
-    launchGroupHandlePtr = AllocaInst(LLVMTypes::VoidPointerType, "launch_group_handle");
-    StoreInst(llvm::Constant::getNullValue(LLVMTypes::VoidPointerType), launchGroupHandlePtr);
+    launchGroupHandleAddressInfo = AllocaInst(LLVMTypes::VoidPointerType, "launch_group_handle");
+    StoreInst(llvm::Constant::getNullValue(LLVMTypes::VoidPointerType), launchGroupHandleAddressInfo->getPointer());
 
     disableGSWarningCount = 0;
 
     const Type *returnType = function->GetReturnType();
     if (!returnType || returnType->IsVoidType())
-        returnValuePtr = NULL;
+        returnValueAddressInfo = NULL;
     else {
-        returnValuePtr = AllocaInst(returnType, "return_value_memory");
+        returnValueAddressInfo = AllocaInst(returnType, "return_value_memory");
     }
 
 #ifdef ISPC_XE_ENABLED
@@ -299,7 +301,7 @@ FunctionEmitContext::FunctionEmitContext(Function *func, Symbol *funSym, llvm::F
         /* Create return point for Xe */
         returnPoint = llvm::BasicBlock::Create(*g->ctx, "return_point", llvmFunction, 0);
         /* Load return value and return it */
-        if (returnValuePtr != NULL) {
+        if (returnValueAddressInfo != NULL) {
             // We have value(s) to return; load them from their storage
             // location
             // Note that LoadInst() needs to be used instead of direct llvm instruction generation
@@ -307,9 +309,9 @@ FunctionEmitContext::FunctionEmitContext(Function *func, Symbol *funSym, llvm::F
             // is i8, while in SSa form they are l1)
             auto bb = GetCurrentBasicBlock();
             SetCurrentBasicBlock(returnPoint);
-            llvm::Value *retVal = LoadInst(returnValuePtr, returnType, "return_value");
+            llvm::Value *retVal = LoadInst(returnValueAddressInfo->getPointer(), returnType, "return_value");
             SetCurrentBasicBlock(bb);
-            // llvm::Value *retVal = new llvm::LoadInst(returnValuePtr, "return_value", returnPoint);
+            // llvm::Value *retVal = new llvm::LoadInst(returnValueAddressInfo, "return_value", returnPoint);
             llvm::ReturnInst::Create(*g->ctx, retVal, returnPoint);
         } else {
             llvm::ReturnInst::Create(*g->ctx, returnPoint);
@@ -422,35 +424,37 @@ llvm::BasicBlock *FunctionEmitContext::GetCurrentBasicBlock() { return bblock; }
 
 void FunctionEmitContext::SetCurrentBasicBlock(llvm::BasicBlock *bb) { bblock = bb; }
 
-llvm::Value *FunctionEmitContext::GetFunctionMask() { return fullMaskPointer ? functionMaskValue : LLVMMaskAllOn; }
+llvm::Value *FunctionEmitContext::GetFunctionMask() { return fullMaskAddressInfo ? functionMaskValue : LLVMMaskAllOn; }
 
-llvm::Value *FunctionEmitContext::GetInternalMask() { return LoadInst(internalMaskPointer, NULL, "load_mask"); }
+llvm::Value *FunctionEmitContext::GetInternalMask() {
+    return LoadInst(internalMaskAddressInfo->getPointer(), NULL, "load_mask");
+}
 
 llvm::Value *FunctionEmitContext::GetFullMask() {
-    return fullMaskPointer ? BinaryOperator(llvm::Instruction::And, GetInternalMask(), functionMaskValue,
-                                            "internal_mask&function_mask")
-                           : GetInternalMask();
+    return fullMaskAddressInfo ? BinaryOperator(llvm::Instruction::And, GetInternalMask(), functionMaskValue,
+                                                "internal_mask&function_mask")
+                               : GetInternalMask();
 }
 
-llvm::Value *FunctionEmitContext::GetFullMaskPointer() {
-    return fullMaskPointer ? fullMaskPointer : internalMaskPointer;
+AddressInfo *FunctionEmitContext::GetFullMaskAddressInfo() {
+    return fullMaskAddressInfo ? fullMaskAddressInfo : internalMaskAddressInfo;
 }
 
 void FunctionEmitContext::SetFunctionMask(llvm::Value *value) {
-    if (fullMaskPointer != NULL) {
+    if (fullMaskAddressInfo != NULL) {
         functionMaskValue = value;
         if (bblock != NULL)
-            StoreInst(GetFullMask(), fullMaskPointer);
+            StoreInst(GetFullMask(), fullMaskAddressInfo->getPointer());
     }
 }
 
 void FunctionEmitContext::SetBlockEntryMask(llvm::Value *value) { blockEntryMask = value; }
 
 void FunctionEmitContext::SetInternalMask(llvm::Value *value) {
-    StoreInst(value, internalMaskPointer);
+    StoreInst(value, internalMaskAddressInfo->getPointer());
     // kludge so that __mask returns the right value in ispc code.
-    if (fullMaskPointer)
-        StoreInst(GetFullMask(), fullMaskPointer);
+    if (fullMaskAddressInfo)
+        StoreInst(GetFullMask(), fullMaskAddressInfo->getPointer());
 }
 
 void FunctionEmitContext::SetInternalMaskAnd(llvm::Value *oldMask, llvm::Value *test) {
@@ -522,29 +526,29 @@ void FunctionEmitContext::EndIf() {
     // leave the lane masks for the program instances that ran those
     // off after we restore the mask after the 'if'.  The code below
     // ends up being optimized out in the case that there were no break
-    // or continue statements (and breakLanesPtr and continueLanesPtr
+    // or continue statements (and breakLanesAddressInfo and continueLanesAddressInfo
     // have their initial 'all off' values), so we don't need to check
     // for that here.
     //
     // There are three general cases to deal with here:
     // - Loops: both break and continue are allowed, and thus the corresponding
     //   lane mask pointers are non-NULL
-    // - Foreach: only continueLanesPtr may be non-NULL
-    // - Switch: only breakLanesPtr may be non-NULL
-    if (continueLanesPtr != NULL || breakLanesPtr != NULL) {
+    // - Foreach: only continueLanesAddressInfo may be non-NULL
+    // - Switch: only breakLanesAddressInfo may be non-NULL
+    if (continueLanesAddressInfo != NULL || breakLanesAddressInfo != NULL) {
         // We want to compute:
         // newMask = (oldMask & ~(breakLanes | continueLanes)),
         // treading breakLanes or continueLanes as "all off" if the
         // corresponding pointer is NULL.
         llvm::Value *bcLanes = NULL;
 
-        if (continueLanesPtr != NULL)
-            bcLanes = LoadInst(continueLanesPtr, NULL, "continue_lanes");
+        if (continueLanesAddressInfo != NULL)
+            bcLanes = LoadInst(continueLanesAddressInfo->getPointer(), NULL, "continue_lanes");
         else
             bcLanes = LLVMMaskAllOff;
 
-        if (breakLanesPtr != NULL) {
-            llvm::Value *breakLanes = LoadInst(breakLanesPtr, NULL, "break_lanes");
+        if (breakLanesAddressInfo != NULL) {
+            llvm::Value *breakLanes = LoadInst(breakLanesAddressInfo->getPointer(), NULL, "break_lanes");
             bcLanes = BinaryOperator(llvm::Instruction::Or, bcLanes, breakLanes, "|break_lanes");
         }
 
@@ -561,20 +565,21 @@ void FunctionEmitContext::StartLoop(llvm::BasicBlock *bt, llvm::BasicBlock *ct,
     // Store the current values of various loop-related state so that we
     // can restore it when we exit this loop.
     llvm::Value *oldMask = GetInternalMask();
-    controlFlowInfo.push_back(CFInfo::GetLoop(uniformCF, isEmulatedUniform, breakTarget, continueTarget, breakLanesPtr,
-                                              continueLanesPtr, oldMask, blockEntryMask));
+    controlFlowInfo.push_back(CFInfo::GetLoop(uniformCF, isEmulatedUniform, breakTarget, continueTarget,
+                                              breakLanesAddressInfo, continueLanesAddressInfo, oldMask,
+                                              blockEntryMask));
     if (uniformCF)
         // If the loop has a uniform condition, we don't need to track
         // which lanes 'break' or 'continue'; all of the running ones go
         // together, so we just jump
-        breakLanesPtr = continueLanesPtr = NULL;
+        breakLanesAddressInfo = continueLanesAddressInfo = NULL;
     else {
         // For loops with varying conditions, allocate space to store masks
         // that record which lanes have done these
-        continueLanesPtr = AllocaInst(LLVMTypes::MaskType, "continue_lanes_memory");
-        StoreInst(LLVMMaskAllOff, continueLanesPtr);
-        breakLanesPtr = AllocaInst(LLVMTypes::MaskType, "break_lanes_memory");
-        StoreInst(LLVMMaskAllOff, breakLanesPtr);
+        continueLanesAddressInfo = AllocaInst(LLVMTypes::MaskType, "continue_lanes_memory");
+        StoreInst(LLVMMaskAllOff, continueLanesAddressInfo->getPointer());
+        breakLanesAddressInfo = AllocaInst(LLVMTypes::MaskType, "break_lanes_memory");
+        StoreInst(LLVMMaskAllOff, breakLanesAddressInfo->getPointer());
     }
 
     breakTarget = bt;
@@ -614,15 +619,16 @@ void FunctionEmitContext::StartForeach(ForeachType ft, bool isEmulatedUniform) {
     // Store the current values of various loop-related state so that we
     // can restore it when we exit this loop.
     llvm::Value *oldMask = GetInternalMask();
-    controlFlowInfo.push_back(CFInfo::GetForeach(isEmulatedUniform, ft, breakTarget, continueTarget, breakLanesPtr,
-                                                 continueLanesPtr, oldMask, blockEntryMask));
-    breakLanesPtr = NULL;
+    controlFlowInfo.push_back(CFInfo::GetForeach(isEmulatedUniform, ft, breakTarget, continueTarget,
+                                                 breakLanesAddressInfo, continueLanesAddressInfo, oldMask,
+                                                 blockEntryMask));
+    breakLanesAddressInfo = NULL;
     breakTarget = NULL;
 
-    continueLanesPtr = NULL;
+    continueLanesAddressInfo = NULL;
     if (!isEmulatedUniform) {
-        continueLanesPtr = AllocaInst(LLVMTypes::MaskType, "foreach_continue_lanes");
-        StoreInst(LLVMMaskAllOff, continueLanesPtr);
+        continueLanesAddressInfo = AllocaInst(LLVMTypes::MaskType, "foreach_continue_lanes");
+        StoreInst(LLVMMaskAllOff, continueLanesAddressInfo->getPointer());
     }
 
     continueTarget = NULL; // should be set by SetContinueTarget()
@@ -642,7 +648,7 @@ void FunctionEmitContext::restoreMaskGivenReturns(llvm::Value *oldMask) {
     // Restore the mask to the given old mask, but leave off any lanes that
     // executed a return statement.
     // newMask = (oldMask & ~returnedLanes)
-    llvm::Value *returnedLanes = LoadInst(returnedLanesPtr, NULL, "returned_lanes");
+    llvm::Value *returnedLanes = LoadInst(returnedLanesAddressInfo->getPointer(), NULL, "returned_lanes");
     llvm::Value *notReturned = BinaryOperator(llvm::Instruction::Xor, returnedLanes, LLVMMaskAllOn, "~returned_lanes");
     llvm::Value *newMask = BinaryOperator(llvm::Instruction::And, oldMask, notReturned, "new_mask");
     SetInternalMask(newMask);
@@ -696,12 +702,12 @@ void FunctionEmitContext::Break(bool doCoherenceCheck) {
         // break.  In these cases, we need to update the mask of the lanes
         // that have executed a 'break' statement:
         // breakLanes = breakLanes | mask
-        AssertPos(currentPos, breakLanesPtr != NULL);
+        AssertPos(currentPos, breakLanesAddressInfo != NULL);
 
         llvm::Value *mask = GetInternalMask();
-        llvm::Value *breakMask = LoadInst(breakLanesPtr, NULL, "break_mask");
+        llvm::Value *breakMask = LoadInst(breakLanesAddressInfo->getPointer(), NULL, "break_mask");
         llvm::Value *newMask = BinaryOperator(llvm::Instruction::Or, mask, breakMask, "mask|break_mask");
-        StoreInst(newMask, breakLanesPtr);
+        StoreInst(newMask, breakLanesAddressInfo->getPointer());
 
         // Set the current mask to be all off, just in case there are any
         // statements in the same scope after the 'break'.  Most of time
@@ -755,11 +761,11 @@ void FunctionEmitContext::Continue(bool doCoherenceCheck) {
     } else {
         // Otherwise update the stored value of which lanes have 'continue'd.
         // continueLanes = continueLanes | mask
-        AssertPos(currentPos, continueLanesPtr);
+        AssertPos(currentPos, continueLanesAddressInfo);
         llvm::Value *mask = GetInternalMask();
-        llvm::Value *continueMask = LoadInst(continueLanesPtr, NULL, "continue_mask");
+        llvm::Value *continueMask = LoadInst(continueLanesAddressInfo->getPointer(), NULL, "continue_mask");
         llvm::Value *newMask = BinaryOperator(llvm::Instruction::Or, mask, continueMask, "mask|continueMask");
-        StoreInst(newMask, continueLanesPtr);
+        StoreInst(newMask, continueLanesAddressInfo->getPointer());
 
         // And set the current mask to be all off in case there are any
         // statements in the same scope after the 'continue'
@@ -795,20 +801,20 @@ bool FunctionEmitContext::ifsInCFAllUniform(int type) const {
 void FunctionEmitContext::jumpIfAllLoopLanesAreDone(llvm::BasicBlock *target) {
     llvm::Value *allDone = NULL;
 
-    if (breakLanesPtr == NULL) {
-        llvm::Value *continued = LoadInst(continueLanesPtr, NULL, "continue_lanes");
+    if (breakLanesAddressInfo == NULL) {
+        llvm::Value *continued = LoadInst(continueLanesAddressInfo->getPointer(), NULL, "continue_lanes");
         continued = BinaryOperator(llvm::Instruction::And, continued, GetFunctionMask(), "continued&func");
         allDone = MasksAllEqual(continued, blockEntryMask);
     } else {
         // Check to see if (returned lanes | continued lanes | break lanes) is
         // equal to the value of mask at the start of the loop iteration.  If
         // so, everyone is done and we can jump to the given target
-        llvm::Value *returned = LoadInst(returnedLanesPtr, NULL, "returned_lanes");
-        llvm::Value *breaked = LoadInst(breakLanesPtr, NULL, "break_lanes");
+        llvm::Value *returned = LoadInst(returnedLanesAddressInfo->getPointer(), NULL, "returned_lanes");
+        llvm::Value *breaked = LoadInst(breakLanesAddressInfo->getPointer(), NULL, "break_lanes");
         llvm::Value *finishedLanes = BinaryOperator(llvm::Instruction::Or, returned, breaked, "returned|breaked");
-        if (continueLanesPtr != NULL) {
+        if (continueLanesAddressInfo != NULL) {
             // It's NULL for "switch" statements...
-            llvm::Value *continued = LoadInst(continueLanesPtr, NULL, "continue_lanes");
+            llvm::Value *continued = LoadInst(continueLanesAddressInfo->getPointer(), NULL, "continue_lanes");
             finishedLanes =
                 BinaryOperator(llvm::Instruction::Or, finishedLanes, continued, "returned|breaked|continued");
         }
@@ -837,45 +843,45 @@ void FunctionEmitContext::jumpIfAllLoopLanesAreDone(llvm::BasicBlock *target) {
 }
 
 void FunctionEmitContext::RestoreContinuedLanes() {
-    if (continueLanesPtr == NULL)
+    if (continueLanesAddressInfo == NULL)
         return;
 
     // mask = mask & continueFlags
     llvm::Value *mask = GetInternalMask();
-    llvm::Value *continueMask = LoadInst(continueLanesPtr, NULL, "continue_mask");
+    llvm::Value *continueMask = LoadInst(continueLanesAddressInfo->getPointer(), NULL, "continue_mask");
     llvm::Value *orMask = BinaryOperator(llvm::Instruction::Or, mask, continueMask, "mask|continue_mask");
     SetInternalMask(orMask);
 
     // continueLanes = 0
-    StoreInst(LLVMMaskAllOff, continueLanesPtr);
+    StoreInst(LLVMMaskAllOff, continueLanesAddressInfo->getPointer());
 }
 
 void FunctionEmitContext::ClearBreakLanes() {
-    if (breakLanesPtr == NULL)
+    if (breakLanesAddressInfo == NULL)
         return;
 
     // breakLanes = 0
-    StoreInst(LLVMMaskAllOff, breakLanesPtr);
+    StoreInst(LLVMMaskAllOff, breakLanesAddressInfo->getPointer());
 }
 
 void FunctionEmitContext::StartSwitch(bool cfIsUniform, llvm::BasicBlock *bbBreak, bool isEmulatedUniform) {
     llvm::Value *oldMask = GetInternalMask();
     controlFlowInfo.push_back(CFInfo::GetSwitch(cfIsUniform, isEmulatedUniform, breakTarget, continueTarget,
-                                                breakLanesPtr, continueLanesPtr, oldMask, blockEntryMask, switchExpr,
-                                                switchFallThroughMaskPtr, defaultBlock, caseBlocks, nextBlocks,
-                                                switchConditionWasUniform));
+                                                breakLanesAddressInfo, continueLanesAddressInfo, oldMask,
+                                                blockEntryMask, switchExpr, switchFallThroughMaskAddressInfo,
+                                                defaultBlock, caseBlocks, nextBlocks, switchConditionWasUniform));
 
-    breakLanesPtr = AllocaInst(LLVMTypes::MaskType, "break_lanes_memory");
-    StoreInst(LLVMMaskAllOff, breakLanesPtr);
+    breakLanesAddressInfo = AllocaInst(LLVMTypes::MaskType, "break_lanes_memory");
+    StoreInst(LLVMMaskAllOff, breakLanesAddressInfo->getPointer());
     breakTarget = bbBreak;
 
-    continueLanesPtr = NULL;
+    continueLanesAddressInfo = NULL;
     continueTarget = NULL;
     blockEntryMask = NULL;
 
     // These will be set by the SwitchInst() method
     switchExpr = NULL;
-    switchFallThroughMaskPtr = NULL;
+    switchFallThroughMaskAddressInfo = NULL;
     defaultBlock = NULL;
     caseBlocks = NULL;
     nextBlocks = NULL;
@@ -1071,7 +1077,7 @@ void FunctionEmitContext::EmitCaseLabel(int value, bool checkMask, SourcePos pos
             // EM will be restored after this branch.
             // We need to skip case check for lanes that are
             // turned on at this point.
-            StoreInst(XeSimdCFPredicate(LLVMMaskAllOn), switchFallThroughMaskPtr);
+            StoreInst(XeSimdCFPredicate(LLVMMaskAllOn), switchFallThroughMaskAddressInfo->getPointer());
         }
 
         if (emitXeHardwareMask() && !inXeSimdCF()) {
@@ -1095,7 +1101,8 @@ void FunctionEmitContext::EmitCaseLabel(int value, bool checkMask, SourcePos pos
         llvm::Value *caseTest = NULL;
         if (llvm::isa<llvm::VectorType>(switchExpr->getType())) {
             // Take fall through lanes to turn them on in the next block
-            llvm::Value *fallThroughMask = LoadInst(switchFallThroughMaskPtr, NULL, "fall_through_mask");
+            llvm::Value *fallThroughMask =
+                LoadInst(switchFallThroughMaskAddressInfo->getPointer(), NULL, "fall_through_mask");
             llvm::Value *val =
                 (switchExpr->getType() == LLVMTypes::Int32VectorType) ? LLVMInt32Vector(value) : LLVMInt64Vector(value);
             llvm::Value *cmpVal =
@@ -1174,8 +1181,8 @@ void FunctionEmitContext::SwitchInst(llvm::Value *expr, llvm::BasicBlock *bbDefa
     } else {
         if (emitXeHardwareMask()) {
             // Init fall through mask
-            switchFallThroughMaskPtr = AllocaInst(LLVMTypes::MaskType, "fall_through_mask");
-            StoreInst(LLVMMaskAllOff, switchFallThroughMaskPtr);
+            switchFallThroughMaskAddressInfo = AllocaInst(LLVMTypes::MaskType, "fall_through_mask");
+            StoreInst(LLVMMaskAllOff, switchFallThroughMaskAddressInfo->getPointer());
         } else {
             // For a varying switch, we first turn off all lanes of the mask
             SetInternalMask(LLVMMaskAllOff);
@@ -1272,13 +1279,13 @@ void FunctionEmitContext::CurrentLanesReturned(Expr *expr, bool doCoherenceCheck
             llvm::Value *retVal = expr->GetValue(this);
             if (retVal != NULL) {
                 if (returnType->IsUniformType() || CastType<ReferenceType>(returnType) != NULL)
-                    StoreInst(retVal, returnValuePtr, returnType, returnType->IsUniformType());
+                    StoreInst(retVal, returnValueAddressInfo->getPointer(), returnType, returnType->IsUniformType());
                 else {
                     // Use a masked store to store the value of the expression
                     // in the return value memory; this preserves the return
                     // values from other lanes that may have executed return
                     // statements previously.
-                    StoreInst(retVal, returnValuePtr, GetInternalMask(), returnType,
+                    StoreInst(retVal, returnValueAddressInfo->getPointer(), GetInternalMask(), returnType,
                               PointerType::GetUniform(returnType));
                 }
             }
@@ -1297,7 +1304,7 @@ void FunctionEmitContext::CurrentLanesReturned(Expr *expr, bool doCoherenceCheck
     } else {
         // Otherwise we update the returnedLanes value by ANDing it with
         // the current lane mask.
-        llvm::Value *oldReturnedLanes = LoadInst(returnedLanesPtr, NULL, "old_returned_lanes");
+        llvm::Value *oldReturnedLanes = LoadInst(returnedLanesAddressInfo->getPointer(), NULL, "old_returned_lanes");
         llvm::Value *newReturnedLanes =
             BinaryOperator(llvm::Instruction::Or, oldReturnedLanes, GetFullMask(), "old_mask|returned_lanes");
 
@@ -1316,10 +1323,10 @@ void FunctionEmitContext::CurrentLanesReturned(Expr *expr, bool doCoherenceCheck
 
             bblock = bNoReturn;
         }
-        // Otherwise update returnedLanesPtr and turn off all of the lanes
+        // Otherwise update returnedLanesAddressInfo and turn off all of the lanes
         // in the current mask so that any subsequent statements in the
         // same scope after the return have no effect
-        StoreInst(newReturnedLanes, returnedLanesPtr);
+        StoreInst(newReturnedLanes, returnedLanesAddressInfo->getPointer());
         AddInstrumentationPoint("return: some but not all lanes have returned");
         SetInternalMask(LLVMMaskAllOff);
     }
@@ -1557,8 +1564,8 @@ void FunctionEmitContext::EmitVariableDebugInfo(Symbol *sym) {
 
     llvm::DebugLoc diLoc =
         llvm::DILocation::get(scope->getContext(), sym->pos.first_line, sym->pos.first_column, scope, nullptr, false);
-    llvm::Instruction *declareInst =
-        m->diBuilder->insertDeclare(sym->storagePtr, var, m->diBuilder->createExpression(), diLoc, bblock);
+    llvm::Instruction *declareInst = m->diBuilder->insertDeclare(sym->storageInfo->getPointer(), var,
+                                                                 m->diBuilder->createExpression(), diLoc, bblock);
     AddDebugPos(declareInst, &sym->pos, scope);
 }
 
@@ -1575,8 +1582,8 @@ void FunctionEmitContext::EmitFunctionParameterDebugInfo(Symbol *sym, int argNum
 
     llvm::DebugLoc diLoc =
         llvm::DILocation::get(scope->getContext(), sym->pos.first_line, sym->pos.first_column, scope, nullptr, false);
-    llvm::Instruction *declareInst =
-        m->diBuilder->insertDeclare(sym->storagePtr, var, m->diBuilder->createExpression(), diLoc, bblock);
+    llvm::Instruction *declareInst = m->diBuilder->insertDeclare(sym->storageInfo->getPointer(), var,
+                                                                 m->diBuilder->createExpression(), diLoc, bblock);
     AddDebugPos(declareInst, &sym->pos, scope);
 }
 
@@ -2641,7 +2648,7 @@ llvm::Value *FunctionEmitContext::AddrSpaceCast(llvm::Value *val, AddressSpace a
     return inst;
 }
 
-llvm::Value *FunctionEmitContext::AllocaInst(llvm::Type *llvmType, llvm::Value *size, const llvm::Twine &name,
+AddressInfo *FunctionEmitContext::AllocaInst(llvm::Type *llvmType, llvm::Value *size, const llvm::Twine &name,
                                              int align, bool atEntryBlock) {
     if ((llvmType == NULL) || (size == NULL)) {
         AssertPos(currentPos, m->errorCount > 0);
@@ -2674,10 +2681,11 @@ llvm::Value *FunctionEmitContext::AllocaInst(llvm::Type *llvmType, llvm::Value *
     if (align != 0) {
         inst->setAlignment(llvm::MaybeAlign(align).valueOrOne());
     }
-    return inst;
+    return new AddressInfo(inst, llvmType);
+    ;
 }
 
-llvm::Value *FunctionEmitContext::AllocaInst(llvm::Type *llvmType, const llvm::Twine &name, int align,
+AddressInfo *FunctionEmitContext::AllocaInst(llvm::Type *llvmType, const llvm::Twine &name, int align,
                                              bool atEntryBlock) {
     if (llvmType == NULL) {
         AssertPos(currentPos, m->errorCount > 0);
@@ -2711,10 +2719,10 @@ llvm::Value *FunctionEmitContext::AllocaInst(llvm::Type *llvmType, const llvm::T
         inst->setAlignment(llvm::MaybeAlign(align).valueOrOne());
     }
     // Don't add debugging info to alloca instructions
-    return inst;
+    return new AddressInfo(inst, llvmType);
 }
 
-llvm::Value *FunctionEmitContext::AllocaInst(const Type *ptrType, const llvm::Twine &name, int align,
+AddressInfo *FunctionEmitContext::AllocaInst(const Type *ptrType, const llvm::Twine &name, int align,
                                              bool atEntryBlock) {
     if (ptrType == NULL) {
         AssertPos(currentPos, m->errorCount > 0);
@@ -3412,14 +3420,14 @@ llvm::Value *FunctionEmitContext::CallInst(llvm::Value *func, const FunctionType
         llvm::Type *llvmReturnType = returnType->LLVMType(g->ctx);
         llvm::Value *resultPtr = NULL;
         if (llvmReturnType->isVoidTy() == false)
-            resultPtr = AllocaInst(returnType);
+            resultPtr = AllocaInst(returnType)->getPointer();
 
         // The memory pointed to by maskPointer tracks the set of program
         // instances for which we still need to call the function they are
         // pointing to.  It starts out initialized with the mask of
         // currently running program instances.
         llvm::Value *oldFullMask = NULL;
-        llvm::Value *maskPtr = AllocaInst(LLVMTypes::MaskType);
+        llvm::Value *maskPtr = AllocaInst(LLVMTypes::MaskType)->getPointer();
         if (emitXeHardwareMask()) {
 #ifdef ISPC_XE_ENABLED
             // Current mask will be calculated according to EM mask
@@ -3581,10 +3589,10 @@ llvm::Instruction *FunctionEmitContext::ReturnInst() {
 #endif
 
     llvm::Instruction *rinst = NULL;
-    if (returnValuePtr != NULL) {
+    if (returnValueAddressInfo != NULL) {
         // We have value(s) to return; load them from their storage
         // location
-        llvm::Value *retVal = LoadInst(returnValuePtr, function->GetReturnType(), "return_value");
+        llvm::Value *retVal = LoadInst(returnValueAddressInfo->getPointer(), function->GetReturnType(), "return_value");
         rinst = llvm::ReturnInst::Create(*g->ctx, retVal, bblock);
     } else {
         AssertPos(currentPos, function->GetReturnType()->IsVoidType());
@@ -3637,7 +3645,7 @@ llvm::Value *FunctionEmitContext::LaunchInst(llvm::Value *callee, std::vector<ll
     int align = 4 * RoundUpPow2(g->target->getNativeVectorWidth());
 
     std::vector<llvm::Value *> allocArgs;
-    allocArgs.push_back(launchGroupHandlePtr);
+    allocArgs.push_back(launchGroupHandleAddressInfo->getPointer());
     allocArgs.push_back(structSize);
     allocArgs.push_back(LLVMInt32(align));
     llvm::Value *voidmem = CallInst(falloc, NULL, allocArgs, "args_ptr");
@@ -3665,7 +3673,7 @@ llvm::Value *FunctionEmitContext::LaunchInst(llvm::Value *callee, std::vector<ll
     llvm::Function *flaunch = m->module->getFunction("ISPCLaunch");
     AssertPos(currentPos, flaunch != NULL);
     std::vector<llvm::Value *> args;
-    args.push_back(launchGroupHandlePtr);
+    args.push_back(launchGroupHandleAddressInfo->getPointer());
     args.push_back(fptr);
     args.push_back(voidmem);
     args.push_back(launchCount[0]);
@@ -3680,7 +3688,7 @@ void FunctionEmitContext::SyncInst() {
         return;
     }
 
-    llvm::Value *launchGroupHandle = LoadInst(launchGroupHandlePtr);
+    llvm::Value *launchGroupHandle = LoadInst(launchGroupHandleAddressInfo->getPointer());
     llvm::Value *nullPtrValue = llvm::Constant::getNullValue(LLVMTypes::VoidPointerType);
     llvm::Value *nonNull = CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_NE, launchGroupHandle, nullPtrValue);
     llvm::BasicBlock *bSync = CreateBasicBlock("call_sync");
@@ -3695,7 +3703,7 @@ void FunctionEmitContext::SyncInst() {
 
     // zero out the handle so that if ISPCLaunch is called again in this
     // function, it knows it's starting out from scratch
-    StoreInst(nullPtrValue, launchGroupHandlePtr);
+    StoreInst(nullPtrValue, launchGroupHandleAddressInfo->getPointer());
 
     BranchInst(bPostSync);
 
@@ -3748,11 +3756,11 @@ CFInfo *FunctionEmitContext::popCFState() {
     if (ci->IsSwitch()) {
         breakTarget = ci->savedBreakTarget;
         continueTarget = ci->savedContinueTarget;
-        breakLanesPtr = ci->savedBreakLanesPtr;
-        continueLanesPtr = ci->savedContinueLanesPtr;
+        breakLanesAddressInfo = ci->savedBreakLanesAddressInfo;
+        continueLanesAddressInfo = ci->savedContinueLanesAddressInfo;
         blockEntryMask = ci->savedBlockEntryMask;
         switchExpr = ci->savedSwitchExpr;
-        switchFallThroughMaskPtr = ci->savedSwitchFallThroughMaskPtr;
+        switchFallThroughMaskAddressInfo = ci->savedSwitchFallThroughMaskAddressInfo;
         defaultBlock = ci->savedDefaultBlock;
         caseBlocks = ci->savedCaseBlocks;
         nextBlocks = ci->savedNextBlocks;
@@ -3760,8 +3768,8 @@ CFInfo *FunctionEmitContext::popCFState() {
     } else if (ci->IsLoop() || ci->IsForeach()) {
         breakTarget = ci->savedBreakTarget;
         continueTarget = ci->savedContinueTarget;
-        breakLanesPtr = ci->savedBreakLanesPtr;
-        continueLanesPtr = ci->savedContinueLanesPtr;
+        breakLanesAddressInfo = ci->savedBreakLanesAddressInfo;
+        continueLanesAddressInfo = ci->savedContinueLanesAddressInfo;
         blockEntryMask = ci->savedBlockEntryMask;
     } else {
         AssertPos(currentPos, ci->IsIf());
@@ -3842,7 +3850,7 @@ llvm::Value *FunctionEmitContext::XePrepareVectorBranch(llvm::Value *value) {
 llvm::Value *FunctionEmitContext::XeStartUnmaskedRegion() {
     auto Fn = llvm::GenXIntrinsic::getGenXDeclaration(m->module, llvm::GenXIntrinsic::genx_unmask_begin);
     std::vector<llvm::Value *> args;
-    llvm::Value *maskAlloca = AllocaInst(LLVMTypes::Int32Type);
+    llvm::Value *maskAlloca = AllocaInst(LLVMTypes::Int32Type)->getPointer();
     llvm::Value *execMask = llvm::CallInst::Create(Fn, args, "", bblock);
     StoreInst(execMask, maskAlloca);
     return maskAlloca;
diff --git a/src/ctx.h b/src/ctx.h
index 7ceaa7f..96ab348 100644
--- a/src/ctx.h
+++ b/src/ctx.h
@@ -126,9 +126,9 @@ class FunctionEmitContext {
         the function entry mask and the internal mask. */
     llvm::Value *GetFullMask();
 
-    /** Returns a pointer to storage in memory that stores the current full
+    /** Returns an AddressInfo with a pointer to storage in memory that stores the current full
         mask. */
-    llvm::Value *GetFullMaskPointer();
+    AddressInfo *GetFullMaskAddressInfo();
 
     /** Provides the value of the mask at function entry */
     void SetFunctionMask(llvm::Value *val);
@@ -499,7 +499,7 @@ class FunctionEmitContext {
         instruction is added at the start of the function in the entry
         basic block; if it should be added to the current basic block, then
         the atEntryBlock parameter should be false. */
-    llvm::Value *AllocaInst(llvm::Type *llvmType, llvm::Value *size, const llvm::Twine &name = "", int align = 0,
+    AddressInfo *AllocaInst(llvm::Type *llvmType, llvm::Value *size, const llvm::Twine &name = "", int align = 0,
                             bool atEntryBlock = true);
     /** Emits an alloca instruction to allocate stack storage for the given
         type.  If a non-zero alignment is specified, the object is also
@@ -507,7 +507,7 @@ class FunctionEmitContext {
         instruction is added at the start of the function in the entry
         basic block; if it should be added to the current basic block, then
         the atEntryBlock parameter should be false. */
-    llvm::Value *AllocaInst(llvm::Type *llvmType, const llvm::Twine &name = "", int align = 0,
+    AddressInfo *AllocaInst(llvm::Type *llvmType, const llvm::Twine &name = "", int align = 0,
                             bool atEntryBlock = true);
 
     /** Emits an alloca instruction to allocate stack storage for the given
@@ -519,7 +519,7 @@ class FunctionEmitContext {
         This implementation is preferred when possible. It is needed when
         storage type is different from IR type. For example,
         'unform bool' is 'i1' in IR but stored as 'i8'. */
-    llvm::Value *AllocaInst(const Type *ptrType, const llvm::Twine &name = "", int align = 0, bool atEntryBlock = true);
+    AddressInfo *AllocaInst(const Type *ptrType, const llvm::Twine &name = "", int align = 0, bool atEntryBlock = true);
 
     /** Standard store instruction; for this variant, the lvalue must be a
         single pointer, not a varying lvalue.
@@ -656,14 +656,14 @@ class FunctionEmitContext {
         instructions */
     llvm::BasicBlock *bblock;
 
-    /** Pointer to stack-allocated memory that stores the current value of
+    /** AddressInfo with pointer to stack-allocated memory that stores the current value of
         the full program mask. */
-    llvm::Value *fullMaskPointer;
+    AddressInfo *fullMaskAddressInfo;
 
-    /** Pointer to stack-allocated memory that stores the current value of
+    /** AddressInfo with pointer to stack-allocated memory that stores the current value of
         the program mask representing varying control flow within the
         function. */
-    llvm::Value *internalMaskPointer;
+    AddressInfo *internalMaskAddressInfo;
 
     /** Value of the program mask when the function starts execution.  */
     llvm::Value *functionMaskValue;
@@ -681,16 +681,16 @@ class FunctionEmitContext {
         mask at the start of it. */
     llvm::Value *blockEntryMask;
 
-    /** If currently in a loop body or switch statement, this is a pointer
+    /** If currently in a loop body or switch statement, this is an AddressInfo with pointer
         to memory to store a mask value that represents which of the lanes
         have executed a 'break' statement.  If we're not in a loop body or
         switch, this should be NULL. */
-    llvm::Value *breakLanesPtr;
+    AddressInfo *breakLanesAddressInfo;
 
-    /** Similar to breakLanesPtr, if we're inside a loop, this is a pointer
+    /** Similar to breakLanesAddressInfo, if we're inside a loop, this is an AddressInfo with a pointer
         to memory to record which of the program instances have executed a
         'continue' statement. */
-    llvm::Value *continueLanesPtr;
+    AddressInfo *continueLanesAddressInfo;
 
     /** If we're inside a loop or switch statement, this gives the basic
         block immediately after the current loop or switch, which we will
@@ -720,9 +720,9 @@ class FunctionEmitContext {
         statements after the switch to execute. */
     llvm::Value *switchExpr;
 
-    /** A pointer to memory that contains mask for lanes that should be
+    /** An AddressInfo with a pointer to memory that contains mask for lanes that should be
         active in the next block */
-    llvm::Value *switchFallThroughMaskPtr;
+    AddressInfo *switchFallThroughMaskAddressInfo;
 
     /** Map from case label numbers to the basic block that will hold code
         for that case. */
@@ -745,16 +745,16 @@ class FunctionEmitContext {
     bool switchConditionWasUniform;
     /** @} */
 
-    /** A pointer to memory that records which of the program instances
+    /** AddressInfo with a pointer to memory that records which of the program instances
         have executed a 'return' statement (and are thus really truly done
         running any more instructions in this functions. */
-    llvm::Value *returnedLanesPtr;
+    AddressInfo *returnedLanesAddressInfo;
 
-    /** A pointer to memory to store the return value for the function.
+    /** AddressInfo with a pointer to memory to store the return value for the function.
         Since difference program instances may execute 'return' statements
         at different times, we need to accumulate the return values as they
         come in until we return for real. */
-    llvm::Value *returnValuePtr;
+    AddressInfo *returnValueAddressInfo;
 
     /** The CFInfo structure records information about a nesting level of
         control flow.  This vector lets us see what control flow is going
@@ -780,10 +780,10 @@ class FunctionEmitContext {
     /** True if a 'launch' statement has been encountered in the function. */
     bool launchedTasks;
 
-    /** This is a pointer to a void * that is passed to the ISPCLaunch(),
+    /** This is an AddressInfo with a pointer to a void * that is passed to the ISPCLaunch(),
         ISPCAlloc(), and ISPCSync() routines as a handle to the group ot
         tasks launched from the current function. */
-    llvm::Value *launchGroupHandlePtr;
+    AddressInfo *launchGroupHandleAddressInfo;
 
     /** Nesting count of the number of times calling code has disabled (and
         not yet reenabled) gather/scatter performance warnings. */
diff --git a/src/expr.cpp b/src/expr.cpp
index dc78e22..0e5927f 100644
--- a/src/expr.cpp
+++ b/src/expr.cpp
@@ -1747,7 +1747,7 @@ llvm::Value *lEmitLogicalOp(BinaryExpr::Op op, Expr *arg0, Expr *arg1, FunctionE
         AssertPos(pos, m->errorCount > 0);
         return NULL;
     }
-    llvm::Value *retPtr = ctx->AllocaInst(retType, "logical_op_mem");
+    llvm::Value *retPtr = ctx->AllocaInst(retType, "logical_op_mem")->getPointer();
     llvm::BasicBlock *bbSkipEvalValue1 = ctx->CreateBasicBlock("skip_eval_1", ctx->GetCurrentBasicBlock());
     llvm::BasicBlock *bbEvalValue1 = ctx->CreateBasicBlock("eval_1", bbSkipEvalValue1);
     llvm::BasicBlock *bbLogicalDone = ctx->CreateBasicBlock("logical_op_done", bbEvalValue1);
@@ -3269,7 +3269,7 @@ SelectExpr::SelectExpr(Expr *t, Expr *e1, Expr *e2, SourcePos p) : Expr(p, Selec
 static llvm::Value *lEmitVaryingSelect(FunctionEmitContext *ctx, llvm::Value *test, llvm::Value *expr1,
                                        llvm::Value *expr2, const Type *type) {
 
-    llvm::Value *resultPtr = ctx->AllocaInst(type, "selectexpr_tmp");
+    llvm::Value *resultPtr = ctx->AllocaInst(type, "selectexpr_tmp")->getPointer();
     Assert(resultPtr != NULL);
     // Don't need to worry about masking here
     ctx->StoreInst(expr2, resultPtr, type, type->IsUniformType());
@@ -3393,8 +3393,8 @@ llvm::Value *SelectExpr::GetValue(FunctionEmitContext *ctx) const {
         // Temporary storage to store the values computed for each
         // expression, if any.  (These stay as uninitialized memory if we
         // short circuit around the corresponding expression.)
-        llvm::Value *expr1Ptr = ctx->AllocaInst(expr1->GetType());
-        llvm::Value *expr2Ptr = ctx->AllocaInst(expr1->GetType());
+        llvm::Value *expr1Ptr = ctx->AllocaInst(expr1->GetType())->getPointer();
+        llvm::Value *expr2Ptr = ctx->AllocaInst(expr1->GetType())->getPointer();
 
         if (shortCircuit1)
             lEmitSelectExprCode(ctx, testVal, oldMask, fullMask, expr1, expr1Ptr);
@@ -4350,7 +4350,7 @@ llvm::Value *IndexExpr::GetValue(FunctionEmitContext *ctx) const {
             return NULL;
         }
         ctx->SetDebugPos(pos);
-        llvm::Value *tmpPtr = ctx->AllocaInst(baseExprType, "array_tmp");
+        llvm::Value *tmpPtr = ctx->AllocaInst(baseExprType, "array_tmp")->getPointer();
         ctx->StoreInst(val, tmpPtr, baseExprType, baseExprType->IsUniformType());
 
         // Get a pointer type to the underlying elements
@@ -5025,7 +5025,7 @@ llvm::Value *VectorMemberExpr::GetValue(FunctionEmitContext *ctx) const {
         if (basePtr == NULL || basePtrType == NULL) {
             // Check that expression on the left side is a rvalue expression
             llvm::Value *exprValue = expr->GetValue(ctx);
-            basePtr = ctx->AllocaInst(expr->GetType());
+            basePtr = ctx->AllocaInst(expr->GetType())->getPointer();
             basePtrType = PointerType::GetUniform(exprVectorType);
             if (basePtr == NULL || basePtrType == NULL) {
                 AssertPos(pos, m->errorCount > 0);
@@ -5035,7 +5035,7 @@ llvm::Value *VectorMemberExpr::GetValue(FunctionEmitContext *ctx) const {
         }
 
         // Allocate temporary memory to store the result
-        llvm::Value *resultPtr = ctx->AllocaInst(memberType, "vector_tmp");
+        llvm::Value *resultPtr = ctx->AllocaInst(memberType, "vector_tmp")->getPointer();
 
         if (resultPtr == NULL) {
             AssertPos(pos, m->errorCount > 0);
@@ -5182,7 +5182,7 @@ llvm::Value *MemberExpr::GetValue(FunctionEmitContext *ctx) const {
         }
         ctx->SetDebugPos(pos);
         const Type *exprType = expr->GetType();
-        llvm::Value *ptr = ctx->AllocaInst(exprType, "struct_tmp");
+        llvm::Value *ptr = ctx->AllocaInst(exprType, "struct_tmp")->getPointer();
         ctx->StoreInst(val, ptr, exprType, exprType->IsUniformType());
 
         int elementNumber = getElementNumber();
@@ -7184,7 +7184,7 @@ std::pair<llvm::Constant *, bool> TypeCastExpr::GetConstant(const Type *constTyp
 
     llvm::Value *ptr = NULL;
     if (GetBaseSymbol())
-        ptr = GetBaseSymbol()->storagePtr;
+        ptr = GetBaseSymbol()->storageInfo ? GetBaseSymbol()->storageInfo->getPointer() : NULL;
 
     if (ptr && llvm::dyn_cast<llvm::GlobalVariable>(ptr)) {
         if (CastType<ArrayType>(expr->GetType())) {
@@ -7235,7 +7235,7 @@ llvm::Value *ReferenceExpr::GetValue(FunctionEmitContext *ctx) const {
         return NULL;
     }
 
-    llvm::Value *ptr = ctx->AllocaInst(type);
+    llvm::Value *ptr = ctx->AllocaInst(type)->getPointer();
     ctx->StoreInst(value, ptr, type, expr->GetType()->IsUniformType());
     return ptr;
 }
@@ -7573,7 +7573,7 @@ std::pair<llvm::Constant *, bool> AddressOfExpr::GetConstant(const Type *type) c
     }
     llvm::Value *ptr = NULL;
     if (GetBaseSymbol())
-        ptr = GetBaseSymbol()->storagePtr;
+        ptr = GetBaseSymbol()->storageInfo ? GetBaseSymbol()->storageInfo->getPointer() : NULL;
     if (ptr && llvm::dyn_cast<llvm::GlobalVariable>(ptr)) {
         const Type *eTYPE = GetType();
         if (type->LLVMType(g->ctx) == eTYPE->LLVMType(g->ctx)) {
@@ -7699,7 +7699,8 @@ llvm::Value *AllocaExpr::GetValue(FunctionEmitContext *ctx) const {
     if (llvmValue == NULL)
         return NULL;
     llvm::Value *resultPtr = ctx->AllocaInst((LLVMTypes::VoidPointerType)->PTR_ELT_TYPE(), llvmValue, "allocaExpr", 16,
-                                             false); // 16 byte stack alignment.
+                                             false)
+                                 ->getPointer(); // 16 byte stack alignment.
     return resultPtr;
 }
 
@@ -7749,8 +7750,8 @@ int AllocaExpr::EstimateCost() const { return 0; }
 SymbolExpr::SymbolExpr(Symbol *s, SourcePos p) : Expr(p, SymbolExprID) { symbol = s; }
 
 llvm::Value *SymbolExpr::GetValue(FunctionEmitContext *ctx) const {
-    // storagePtr may be NULL due to an earlier compilation error
-    if (!symbol || !symbol->storagePtr)
+    // storageInfo may be NULL due to an earlier compilation error
+    if (!symbol || !symbol->storageInfo)
         return NULL;
     ctx->SetDebugPos(pos);
 
@@ -7762,14 +7763,14 @@ llvm::Value *SymbolExpr::GetValue(FunctionEmitContext *ctx) const {
         return ctx->XeSimdCFPredicate(LLVMMaskAllOn);
     }
 #endif
-    return ctx->LoadInst(symbol->storagePtr, symbol->type, loadName.c_str());
+    return ctx->LoadInst(symbol->storageInfo->getPointer(), symbol->type, loadName.c_str());
 }
 
 llvm::Value *SymbolExpr::GetLValue(FunctionEmitContext *ctx) const {
     if (symbol == NULL)
         return NULL;
     ctx->SetDebugPos(pos);
-    return symbol->storagePtr;
+    return symbol->storageInfo->getPointer();
 }
 
 const Type *SymbolExpr::GetLValueType() const {
diff --git a/src/func.cpp b/src/func.cpp
index ff97ce4..28f92fb 100644
--- a/src/func.cpp
+++ b/src/func.cpp
@@ -257,7 +257,7 @@ static void lCopyInTaskParameter(int i, llvm::Value *structArgPtr, const std::ve
         return;
 
     // allocate space to copy the parameter in to
-    sym->storagePtr = ctx->AllocaInst(sym->type, sym->name.c_str());
+    sym->storageInfo = ctx->AllocaInst(sym->type, sym->name.c_str());
 
     // get a pointer to the value in the struct
     llvm::Value *ptr = ctx->AddElementOffset(structArgPtr, i, NULL, sym->name.c_str());
@@ -265,7 +265,7 @@ static void lCopyInTaskParameter(int i, llvm::Value *structArgPtr, const std::ve
     // and copy the value from the struct and into the local alloca'ed
     // memory
     llvm::Value *ptrval = ctx->LoadInst(ptr, sym->type, sym->name.c_str());
-    ctx->StoreInst(ptrval, sym->storagePtr, sym->type, sym->type->IsUniformType());
+    ctx->StoreInst(ptrval, sym->storageInfo->getPointer(), sym->type, sym->type->IsUniformType());
     ctx->EmitFunctionParameterDebugInfo(sym, i);
 }
 
@@ -277,7 +277,7 @@ static void lCopyInTaskParameter(int i, llvm::Value *structArgPtr, const std::ve
 void Function::emitCode(FunctionEmitContext *ctx, llvm::Function *function, SourcePos firstStmtPos) {
     // Connect the __mask builtin to the location in memory that stores its
     // value
-    maskSymbol->storagePtr = ctx->GetFullMaskPointer();
+    maskSymbol->storageInfo = ctx->GetFullMaskAddressInfo();
 
     // add debugging info for __mask
     maskSymbol->pos = firstStmtPos;
@@ -329,33 +329,33 @@ void Function::emitCode(FunctionEmitContext *ctx, llvm::Function *function, Sour
 
         // Copy threadIndex and threadCount into stack-allocated storage so
         // that their symbols point to something reasonable.
-        threadIndexSym->storagePtr = ctx->AllocaInst(LLVMTypes::Int32Type, "threadIndex");
-        ctx->StoreInst(threadIndex, threadIndexSym->storagePtr);
+        threadIndexSym->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "threadIndex");
+        ctx->StoreInst(threadIndex, threadIndexSym->storageInfo->getPointer());
 
-        threadCountSym->storagePtr = ctx->AllocaInst(LLVMTypes::Int32Type, "threadCount");
-        ctx->StoreInst(threadCount, threadCountSym->storagePtr);
+        threadCountSym->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "threadCount");
+        ctx->StoreInst(threadCount, threadCountSym->storageInfo->getPointer());
 
         // Copy taskIndex and taskCount into stack-allocated storage so
         // that their symbols point to something reasonable.
-        taskIndexSym->storagePtr = ctx->AllocaInst(LLVMTypes::Int32Type, "taskIndex");
-        ctx->StoreInst(taskIndex, taskIndexSym->storagePtr);
-
-        taskCountSym->storagePtr = ctx->AllocaInst(LLVMTypes::Int32Type, "taskCount");
-        ctx->StoreInst(taskCount, taskCountSym->storagePtr);
-
-        taskIndexSym0->storagePtr = ctx->AllocaInst(LLVMTypes::Int32Type, "taskIndex0");
-        ctx->StoreInst(taskIndex0, taskIndexSym0->storagePtr);
-        taskIndexSym1->storagePtr = ctx->AllocaInst(LLVMTypes::Int32Type, "taskIndex1");
-        ctx->StoreInst(taskIndex1, taskIndexSym1->storagePtr);
-        taskIndexSym2->storagePtr = ctx->AllocaInst(LLVMTypes::Int32Type, "taskIndex2");
-        ctx->StoreInst(taskIndex2, taskIndexSym2->storagePtr);
-
-        taskCountSym0->storagePtr = ctx->AllocaInst(LLVMTypes::Int32Type, "taskCount0");
-        ctx->StoreInst(taskCount0, taskCountSym0->storagePtr);
-        taskCountSym1->storagePtr = ctx->AllocaInst(LLVMTypes::Int32Type, "taskCount1");
-        ctx->StoreInst(taskCount1, taskCountSym1->storagePtr);
-        taskCountSym2->storagePtr = ctx->AllocaInst(LLVMTypes::Int32Type, "taskCount2");
-        ctx->StoreInst(taskCount2, taskCountSym2->storagePtr);
+        taskIndexSym->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskIndex");
+        ctx->StoreInst(taskIndex, taskIndexSym->storageInfo->getPointer());
+
+        taskCountSym->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskCount");
+        ctx->StoreInst(taskCount, taskCountSym->storageInfo->getPointer());
+
+        taskIndexSym0->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskIndex0");
+        ctx->StoreInst(taskIndex0, taskIndexSym0->storageInfo->getPointer());
+        taskIndexSym1->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskIndex1");
+        ctx->StoreInst(taskIndex1, taskIndexSym1->storageInfo->getPointer());
+        taskIndexSym2->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskIndex2");
+        ctx->StoreInst(taskIndex2, taskIndexSym2->storageInfo->getPointer());
+
+        taskCountSym0->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskCount0");
+        ctx->StoreInst(taskCount0, taskCountSym0->storageInfo->getPointer());
+        taskCountSym1->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskCount1");
+        ctx->StoreInst(taskCount1, taskCountSym1->storageInfo->getPointer());
+        taskCountSym2->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskCount2");
+        ctx->StoreInst(taskCount2, taskCountSym2->storageInfo->getPointer());
     } else {
         // Regular, non-task function or GPU task
         llvm::Function::arg_iterator argIter = function->arg_begin();
@@ -369,7 +369,7 @@ void Function::emitCode(FunctionEmitContext *ctx, llvm::Function *function, Sour
 
             // Allocate stack storage for the parameter and emit code
             // to store the its value there.
-            argSym->storagePtr = ctx->AllocaInst(argSym->type, argSym->name.c_str());
+            argSym->storageInfo = ctx->AllocaInst(argSym->type, argSym->name.c_str());
             // ISPC export and extern "C" functions have addrspace in the declaration on Xe so
             // we cast addrspace from generic to default in the alloca BB.
             // define dso_local spir_func void @test(%S addrspace(4)* noalias %s)
@@ -379,7 +379,7 @@ void Function::emitCode(FunctionEmitContext *ctx, llvm::Function *function, Sour
                 addrCasted = ctx->AddrSpaceCast(&*argIter, AddressSpace::ispc_default, true);
             }
 
-            ctx->StoreInst(addrCasted, argSym->storagePtr, argSym->type);
+            ctx->StoreInst(addrCasted, argSym->storageInfo->getPointer(), argSym->type);
 
             ctx->EmitFunctionParameterDebugInfo(argSym, i);
         }
diff --git a/src/module.cpp b/src/module.cpp
index 58a2ae8..8eaaf33 100644
--- a/src/module.cpp
+++ b/src/module.cpp
@@ -520,7 +520,7 @@ void Module::AddGlobalVariable(const std::string &name, const Type *type, Expr *
             return;
         }
 
-        llvm::GlobalVariable *gv = llvm::dyn_cast<llvm::GlobalVariable>(sym->storagePtr);
+        llvm::GlobalVariable *gv = llvm::dyn_cast<llvm::GlobalVariable>(sym->storageInfo->getPointer());
         Assert(gv != NULL);
 
         // And issue an error if this is a redefinition of a variable
@@ -548,21 +548,22 @@ void Module::AddGlobalVariable(const std::string &name, const Type *type, Expr *
     // Note that the NULL llvmInitializer is what leads to "extern"
     // declarations coming up extern and not defining storage (a bit
     // subtle)...
-    sym->storagePtr = new llvm::GlobalVariable(*module, llvmType, isConst, linkage, llvmInitializer, sym->name.c_str());
+    sym->storageInfo = new AddressInfo(
+        new llvm::GlobalVariable(*module, llvmType, isConst, linkage, llvmInitializer, sym->name.c_str()), llvmType);
 
     // Patch up any references to the previous GlobalVariable (e.g. from a
     // declaration of a global that was later defined.)
     if (oldGV != NULL) {
-        oldGV->replaceAllUsesWith(sym->storagePtr);
+        oldGV->replaceAllUsesWith(sym->storageInfo->getPointer());
         oldGV->removeFromParent();
-        sym->storagePtr->setName(sym->name.c_str());
+        sym->storageInfo->getPointer()->setName(sym->name.c_str());
     }
 
     if (diBuilder) {
         llvm::DIFile *file = pos.GetDIFile();
         llvm::DINamespace *diSpace = pos.GetDINamespace();
         // llvm::MDFile *file = pos.GetDIFile();
-        llvm::GlobalVariable *sym_GV_storagePtr = llvm::dyn_cast<llvm::GlobalVariable>(sym->storagePtr);
+        llvm::GlobalVariable *sym_GV_storagePtr = llvm::dyn_cast<llvm::GlobalVariable>(sym->storageInfo->getPointer());
         Assert(sym_GV_storagePtr);
         llvm::DIGlobalVariableExpression *var = diBuilder->createGlobalVariableExpression(
             diSpace, name, name, file, pos.first_line, sym->type->GetDIType(diSpace), (sym->storageClass == SC_STATIC));
diff --git a/src/stmt.cpp b/src/stmt.cpp
index 6d7b23a..0c61a72 100644
--- a/src/stmt.cpp
+++ b/src/stmt.cpp
@@ -221,14 +221,16 @@ void DeclStmt::EmitCode(FunctionEmitContext *ctx) const {
 
             // Allocate space for the static variable in global scope, so
             // that it persists across function calls
-            sym->storagePtr = new llvm::GlobalVariable(
-                *m->module, llvmType, sym->type->IsConstType(), llvm::GlobalValue::InternalLinkage, cinit,
-                llvm::Twine("static.") + llvm::Twine(sym->pos.first_line) + llvm::Twine(".") + sym->name.c_str());
+            sym->storageInfo = new AddressInfo(
+                new llvm::GlobalVariable(
+                    *m->module, llvmType, sym->type->IsConstType(), llvm::GlobalValue::InternalLinkage, cinit,
+                    llvm::Twine("static.") + llvm::Twine(sym->pos.first_line) + llvm::Twine(".") + sym->name.c_str()),
+                llvmType);
             // Tell the FunctionEmitContext about the variable
             ctx->EmitVariableDebugInfo(sym);
         } else {
             // For non-static variables, allocate storage on the stack
-            sym->storagePtr = ctx->AllocaInst(sym->type, sym->name.c_str());
+            sym->storageInfo = ctx->AllocaInst(sym->type, sym->name.c_str());
 
             // Tell the FunctionEmitContext about the variable; must do
             // this before the initializer stuff.
@@ -241,7 +243,7 @@ void DeclStmt::EmitCode(FunctionEmitContext *ctx) const {
 
             // And then get it initialized...
             sym->parentFunction = ctx->GetFunction();
-            InitSymbol(sym->storagePtr, sym->type, initExpr, ctx, sym->pos);
+            InitSymbol(sym->storageInfo->getPointer(), sym->type, initExpr, ctx, sym->pos);
         }
     }
 }
@@ -1368,8 +1370,9 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     // Setup: compute the number of items we have to work on in each
     // dimension and a number of derived values.
     std::vector<llvm::BasicBlock *> bbReset, bbStep, bbTest;
-    std::vector<llvm::Value *> startVals, endVals, uniformCounterPtrs;
-    std::vector<llvm::Value *> nExtras, alignedEnd, extrasMaskPtrs;
+    std::vector<llvm::Value *> startVals, endVals;
+    std::vector<llvm::Value *> nExtras, alignedEnd;
+    std::vector<AddressInfo *> uniformCounterPtrs, extrasMaskPtrs;
 
     std::vector<int> span(nDims, 0);
     lGetSpans(nDims - 1, nDims, g->target->getVectorWidth(), isTiled, &span[0]);
@@ -1409,12 +1412,12 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         // dimension.  Its value is only used internally here for looping
         // logic and isn't directly available in the user's program code.
         uniformCounterPtrs.push_back(ctx->AllocaInst(LLVMTypes::Int32Type, "counter"));
-        ctx->StoreInst(startVals[i], uniformCounterPtrs[i]);
+        ctx->StoreInst(startVals[i], uniformCounterPtrs[i]->getPointer());
 
         // There is also a varying variable that holds the set of index
         // values for each dimension in the current loop iteration; this is
         // the value that is program-visible.
-        dimVariables[i]->storagePtr = ctx->AllocaInst(LLVMTypes::Int32VectorType, dimVariables[i]->name.c_str());
+        dimVariables[i]->storageInfo = ctx->AllocaInst(LLVMTypes::Int32VectorType, dimVariables[i]->name.c_str());
         dimVariables[i]->parentFunction = ctx->GetFunction();
         ctx->EmitVariableDebugInfo(dimVariables[i]);
 
@@ -1423,7 +1426,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         // processed.  (i.e. this is used to disable the lanes that have
         // out-of-bounds offsets.)
         extrasMaskPtrs.push_back(ctx->AllocaInst(LLVMTypes::MaskType, "extras mask"));
-        ctx->StoreInst(LLVMMaskAllOn, extrasMaskPtrs[i]);
+        ctx->StoreInst(LLVMMaskAllOn, extrasMaskPtrs[i]->getPointer());
     }
 
     ctx->StartForeach(FunctionEmitContext::FOREACH_REGULAR);
@@ -1440,8 +1443,8 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         if (i == 0)
             ctx->BranchInst(bbExit);
         else {
-            ctx->StoreInst(LLVMMaskAllOn, extrasMaskPtrs[i]);
-            ctx->StoreInst(startVals[i], uniformCounterPtrs[i]);
+            ctx->StoreInst(LLVMMaskAllOn, extrasMaskPtrs[i]->getPointer());
+            ctx->StoreInst(startVals[i], uniformCounterPtrs[i]->getPointer());
             ctx->BranchInst(bbStep[i - 1]);
         }
     }
@@ -1454,10 +1457,10 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     // structure..
     for (int i = 0; i < nDims - 1; ++i) {
         ctx->SetCurrentBasicBlock(bbStep[i]);
-        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[i]);
+        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[i]->getPointer());
         llvm::Value *newCounter =
             ctx->BinaryOperator(llvm::Instruction::Add, counter, LLVMInt32(span[i]), "new_counter");
-        ctx->StoreInst(newCounter, uniformCounterPtrs[i]);
+        ctx->StoreInst(newCounter, uniformCounterPtrs[i]->getPointer());
         ctx->BranchInst(bbTest[i]);
     }
 
@@ -1470,7 +1473,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         llvm::Value *haveExtras =
             ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_SGT, endVals[i], alignedEnd[i], "have_extras");
 
-        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[i], NULL, "counter");
+        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[i]->getPointer(), NULL, "counter");
         llvm::Value *atAlignedEnd =
             ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_EQ, counter, alignedEnd[i], "at_aligned_end");
         llvm::Value *inEx = ctx->BinaryOperator(llvm::Instruction::And, haveExtras, atAlignedEnd, "in_extras");
@@ -1480,8 +1483,8 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         else
             inExtras.push_back(ctx->BinaryOperator(llvm::Instruction::Or, inEx, inExtras[i - 1], "in_extras_all"));
 
-        llvm::Value *varyingCounter =
-            lUpdateVaryingCounter(i, nDims, ctx, uniformCounterPtrs[i], dimVariables[i]->storagePtr, span);
+        llvm::Value *varyingCounter = lUpdateVaryingCounter(i, nDims, ctx, uniformCounterPtrs[i]->getPointer(),
+                                                            dimVariables[i]->storageInfo->getPointer(), span);
 
         llvm::Value *smearEnd = ctx->BroadcastValue(endVals[i], LLVMTypes::Int32VectorType, "smear_end");
 
@@ -1491,11 +1494,11 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         emask = ctx->I1VecToBoolVec(emask);
 
         if (i == 0)
-            ctx->StoreInst(emask, extrasMaskPtrs[i]);
+            ctx->StoreInst(emask, extrasMaskPtrs[i]->getPointer());
         else {
-            llvm::Value *oldMask = ctx->LoadInst(extrasMaskPtrs[i - 1]);
+            llvm::Value *oldMask = ctx->LoadInst(extrasMaskPtrs[i - 1]->getPointer());
             llvm::Value *newMask = ctx->BinaryOperator(llvm::Instruction::And, oldMask, emask, "extras_mask");
-            ctx->StoreInst(newMask, extrasMaskPtrs[i]);
+            ctx->StoreInst(newMask, extrasMaskPtrs[i]->getPointer());
         }
 
         llvm::Value *notAtEnd = ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_SLT, counter, endVals[i]);
@@ -1566,11 +1569,11 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     {
         // Update the varying counter value here, since all subsequent
         // blocks along this path need it.
-        lUpdateVaryingCounter(nDims - 1, nDims, ctx, uniformCounterPtrs[nDims - 1], dimVariables[nDims - 1]->storagePtr,
-                              span);
+        lUpdateVaryingCounter(nDims - 1, nDims, ctx, uniformCounterPtrs[nDims - 1]->getPointer(),
+                              dimVariables[nDims - 1]->storageInfo->getPointer(), span);
 
         // here we just check to see if counter < alignedEnd
-        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1], NULL, "counter");
+        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1]->getPointer(), NULL, "counter");
         llvm::Value *beforeAlignedEnd = ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_SLT, counter,
                                                      alignedEnd[nDims - 1], "before_aligned_end");
         ctx->BranchInst(bbAllInnerPartialOuter, bbPartial, beforeAlignedEnd);
@@ -1592,7 +1595,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     // should step the loop counter for the next enclosing dimension
     // instead.
     // Revisit : Should this be an i1.
-    llvm::Value *stepIndexAfterMaskedBodyPtr = ctx->AllocaInst(LLVMTypes::BoolType, "step_index");
+    llvm::Value *stepIndexAfterMaskedBodyPtr = ctx->AllocaInst(LLVMTypes::BoolType, "step_index")->getPointer();
 
     ///////////////////////////////////////////////////////////////////////////
     // We're in the inner loop part where the only masking is due to outer
@@ -1605,7 +1608,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
             // 1D loop; we shouldn't ever get here anyway
             mask = LLVMMaskAllOff;
         else
-            mask = ctx->LoadInst(extrasMaskPtrs[nDims - 2]);
+            mask = ctx->LoadInst(extrasMaskPtrs[nDims - 2]->getPointer());
 
         ctx->SetInternalMask(mask);
 
@@ -1618,7 +1621,8 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     // for the final bits here
     ctx->SetCurrentBasicBlock(bbPartial);
     {
-        llvm::Value *varyingCounter = ctx->LoadInst(dimVariables[nDims - 1]->storagePtr, dimVariables[nDims - 1]->type);
+        llvm::Value *varyingCounter =
+            ctx->LoadInst(dimVariables[nDims - 1]->storageInfo->getPointer(), dimVariables[nDims - 1]->type);
         llvm::Value *smearEnd = ctx->BroadcastValue(endVals[nDims - 1], LLVMTypes::Int32VectorType, "smear_end");
 
         llvm::Value *emask = ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_SLT, varyingCounter, smearEnd);
@@ -1627,7 +1631,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         if (nDims == 1) {
             ctx->SetInternalMask(emask);
         } else {
-            llvm::Value *oldMask = ctx->LoadInst(extrasMaskPtrs[nDims - 2]);
+            llvm::Value *oldMask = ctx->LoadInst(extrasMaskPtrs[nDims - 2]->getPointer());
             llvm::Value *newMask = ctx->BinaryOperator(llvm::Instruction::And, oldMask, emask, "extras_mask");
             ctx->SetInternalMask(newMask);
         }
@@ -1635,7 +1639,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         ctx->StoreInst(LLVMFalse, stepIndexAfterMaskedBodyPtr);
 
         // check to see if counter != end, otherwise, the next step is not necessary
-        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1], NULL, "counter");
+        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1]->getPointer(), NULL, "counter");
         llvm::Value *atEnd =
             ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_NE, counter, endVals[nDims - 1], "at_end");
         ctx->BranchInst(bbMaskedBody, bbReset[nDims - 1], atEnd);
@@ -1656,7 +1660,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     llvm::BasicBlock *bbPartialInnerAllOuter = ctx->CreateBasicBlock("partial_inner_all_outer");
     ctx->SetCurrentBasicBlock(bbOuterNotInExtras);
     {
-        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1], NULL, "counter");
+        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1]->getPointer(), NULL, "counter");
         llvm::Value *beforeAlignedEnd = ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_SLT, counter,
                                                      alignedEnd[nDims - 1], "before_aligned_end");
         ctx->BranchInst(bbFullBody, bbPartialInnerAllOuter, beforeAlignedEnd);
@@ -1673,8 +1677,8 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     {
         ctx->SetInternalMask(LLVMMaskAllOn);
         ctx->SetBlockEntryMask(LLVMMaskAllOn);
-        lUpdateVaryingCounter(nDims - 1, nDims, ctx, uniformCounterPtrs[nDims - 1], dimVariables[nDims - 1]->storagePtr,
-                              span);
+        lUpdateVaryingCounter(nDims - 1, nDims, ctx, uniformCounterPtrs[nDims - 1]->getPointer(),
+                              dimVariables[nDims - 1]->storageInfo->getPointer(), span);
         ctx->SetContinueTarget(bbFullBodyContinue);
         ctx->AddInstrumentationPoint("foreach loop body (all on)");
         stmts->EmitCode(ctx);
@@ -1684,10 +1688,10 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     ctx->SetCurrentBasicBlock(bbFullBodyContinue);
     {
         ctx->RestoreContinuedLanes();
-        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1]);
+        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1]->getPointer());
         llvm::Value *newCounter =
             ctx->BinaryOperator(llvm::Instruction::Add, counter, LLVMInt32(span[nDims - 1]), "new_counter");
-        ctx->StoreInst(newCounter, uniformCounterPtrs[nDims - 1]);
+        ctx->StoreInst(newCounter, uniformCounterPtrs[nDims - 1]->getPointer());
         ctx->BranchInst(bbOuterNotInExtras);
     }
 
@@ -1698,7 +1702,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     llvm::BasicBlock *bbSetInnerMask = ctx->CreateBasicBlock("partial_inner_only");
     ctx->SetCurrentBasicBlock(bbPartialInnerAllOuter);
     {
-        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1], NULL, "counter");
+        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1]->getPointer(), NULL, "counter");
         llvm::Value *beforeFullEnd = ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_SLT, counter,
                                                   endVals[nDims - 1], "before_full_end");
         ctx->BranchInst(bbSetInnerMask, bbReset[nDims - 1], beforeFullEnd);
@@ -1709,8 +1713,9 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     // mask for the innermost dimension
     ctx->SetCurrentBasicBlock(bbSetInnerMask);
     {
-        llvm::Value *varyingCounter = lUpdateVaryingCounter(nDims - 1, nDims, ctx, uniformCounterPtrs[nDims - 1],
-                                                            dimVariables[nDims - 1]->storagePtr, span);
+        llvm::Value *varyingCounter =
+            lUpdateVaryingCounter(nDims - 1, nDims, ctx, uniformCounterPtrs[nDims - 1]->getPointer(),
+                                  dimVariables[nDims - 1]->storageInfo->getPointer(), span);
         llvm::Value *smearEnd = ctx->BroadcastValue(endVals[nDims - 1], LLVMTypes::Int32VectorType, "smear_end");
         llvm::Value *emask = ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_SLT, varyingCounter, smearEnd);
         emask = ctx->I1VecToBoolVec(emask);
@@ -1751,10 +1756,10 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     // innermost for loop over full vectors.
     ctx->SetCurrentBasicBlock(bbStepInnerIndex);
     {
-        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1]);
+        llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1]->getPointer());
         llvm::Value *newCounter =
             ctx->BinaryOperator(llvm::Instruction::Add, counter, LLVMInt32(span[nDims - 1]), "new_counter");
-        ctx->StoreInst(newCounter, uniformCounterPtrs[nDims - 1]);
+        ctx->StoreInst(newCounter, uniformCounterPtrs[nDims - 1]->getPointer());
         ctx->BranchInst(bbOuterInExtras);
     }
 
@@ -1844,9 +1849,9 @@ void ForeachStmt::EmitCodeForXe(FunctionEmitContext *ctx) const {
         steps.push_back(step);
 
         // Init vectorized counters
-        dimVariables[i]->storagePtr = ctx->AllocaInst(LLVMTypes::Int32VectorType, dimVariables[i]->name.c_str());
+        dimVariables[i]->storageInfo = ctx->AllocaInst(LLVMTypes::Int32VectorType, dimVariables[i]->name.c_str());
         dimVariables[i]->parentFunction = ctx->GetFunction();
-        ctx->StoreInst(sv, dimVariables[i]->storagePtr);
+        ctx->StoreInst(sv, dimVariables[i]->storageInfo->getPointer());
         ctx->EmitVariableDebugInfo(dimVariables[i]);
     }
 
@@ -1867,7 +1872,7 @@ void ForeachStmt::EmitCodeForXe(FunctionEmitContext *ctx) const {
             ctx->BranchInst(bbExit);
         else {
             // Reset counter for this dimension, iterate over previous one
-            ctx->StoreInst(startVals[i], dimVariables[i]->storagePtr);
+            ctx->StoreInst(startVals[i], dimVariables[i]->storageInfo->getPointer());
             ctx->BranchInst(bbStep[i - 1]);
         }
     }
@@ -1877,9 +1882,9 @@ void ForeachStmt::EmitCodeForXe(FunctionEmitContext *ctx) const {
     // entering foreach.
     for (int i = 0; i < nDims; ++i) {
         ctx->SetCurrentBasicBlock(bbStep[i]);
-        llvm::Value *counter = ctx->LoadInst(dimVariables[i]->storagePtr);
+        llvm::Value *counter = ctx->LoadInst(dimVariables[i]->storageInfo->getPointer());
         llvm::Value *newCounter = ctx->BinaryOperator(llvm::Instruction::Add, counter, steps[i], "new_counter");
-        ctx->StoreInst(newCounter, dimVariables[i]->storagePtr);
+        ctx->StoreInst(newCounter, dimVariables[i]->storageInfo->getPointer());
         ctx->BranchInst(bbTest[i]);
     }
 
@@ -1899,7 +1904,7 @@ void ForeachStmt::EmitCodeForXe(FunctionEmitContext *ctx) const {
     // this stuff doesn't matter: we will exit loop after this iteration anyway.
     for (int i = 0; i < nDims; ++i) {
         ctx->SetCurrentBasicBlock(bbTest[i]);
-        llvm::Value *val = ctx->LoadInst(dimVariables[i]->storagePtr, NULL, "val");
+        llvm::Value *val = ctx->LoadInst(dimVariables[i]->storageInfo->getPointer(), NULL, "val");
         llvm::Value *checkVal = ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_SLT, val, endVals[i]);
         // Target is body for innermost dimension, next dimension test for others
         llvm::BasicBlock *targetBB = (i < nDims - 1) ? bbTest[i + 1] : bbBody;
@@ -2053,7 +2058,7 @@ void ForeachActiveStmt::EmitCode(FunctionEmitContext *ctx) const {
         return;
     }
     Assert(Type::Equal(sym->type, AtomicType::UniformInt64->GetAsConstType()));
-    sym->storagePtr = ctx->AllocaInst(LLVMTypes::Int64Type, sym->name.c_str());
+    sym->storageInfo = ctx->AllocaInst(LLVMTypes::Int64Type, sym->name.c_str());
 
     ctx->SetDebugPos(pos);
     ctx->EmitVariableDebugInfo(sym);
@@ -2083,7 +2088,7 @@ void ForeachActiveStmt::EmitCode(FunctionEmitContext *ctx) const {
 #endif
         oldFullMask = ctx->GetFullMask();
 
-    llvm::Value *maskBitsPtr = ctx->AllocaInst(LLVMTypes::Int64Type, "mask_bits");
+    llvm::Value *maskBitsPtr = ctx->AllocaInst(LLVMTypes::Int64Type, "mask_bits")->getPointer();
     llvm::Value *movmsk = ctx->LaneMask(oldFullMask);
     ctx->StoreInst(movmsk, maskBitsPtr);
 
@@ -2107,7 +2112,7 @@ void ForeachActiveStmt::EmitCode(FunctionEmitContext *ctx) const {
 
         // Store that value into the storage allocated for the iteration
         // variable.
-        ctx->StoreInst(firstSet, sym->storagePtr, sym->type);
+        ctx->StoreInst(firstSet, sym->storageInfo->getPointer(), sym->type);
 
         // Now set the execution mask to be only on for the current program
         // instance.  (TODO: is there a more efficient way to do this? e.g.
@@ -2249,7 +2254,7 @@ void ForeachUniqueStmt::EmitCode(FunctionEmitContext *ctx) const {
         return;
     }
 
-    sym->storagePtr = ctx->AllocaInst(sym->type, sym->name.c_str());
+    sym->storageInfo = ctx->AllocaInst(sym->type, sym->name.c_str());
 
     ctx->SetDebugPos(pos);
     ctx->EmitVariableDebugInfo(sym);
@@ -2282,7 +2287,7 @@ void ForeachUniqueStmt::EmitCode(FunctionEmitContext *ctx) const {
 #endif
         oldFullMask = ctx->GetFullMask();
 
-    llvm::Value *maskBitsPtr = ctx->AllocaInst(LLVMTypes::Int64Type, "mask_bits");
+    llvm::Value *maskBitsPtr = ctx->AllocaInst(LLVMTypes::Int64Type, "mask_bits")->getPointer();
     llvm::Value *movmsk = ctx->LaneMask(oldFullMask);
     ctx->StoreInst(movmsk, maskBitsPtr);
 
@@ -2302,7 +2307,7 @@ void ForeachUniqueStmt::EmitCode(FunctionEmitContext *ctx) const {
         return;
     }
     ctx->SetDebugPos(pos);
-    llvm::Value *exprMem = ctx->AllocaInst(exprType, "expr_mem");
+    llvm::Value *exprMem = ctx->AllocaInst(exprType, "expr_mem")->getPointer();
     ctx->StoreInst(exprValue, exprMem, exprType);
 
     // Onward to find the first set of lanes to run the loop for
@@ -2335,7 +2340,7 @@ void ForeachUniqueStmt::EmitCode(FunctionEmitContext *ctx) const {
         Assert(uniqueValue != NULL);
         // Store that value in sym's storage so that the iteration variable
         // has the right value inside the loop body
-        ctx->StoreInst(uniqueValue, sym->storagePtr, sym->type);
+        ctx->StoreInst(uniqueValue, sym->storageInfo->getPointer(), sym->type);
 
         // Set the execution mask so that it's on for any lane that a) was
         // running at the start of the foreach loop, and b) where that
@@ -3493,7 +3498,7 @@ static llvm::Value *lEmitPrintArgCode(Expr *expr, FunctionEmitContext *ctx) {
     const Type *type = expr->GetType();
 
     llvm::Type *llvmExprType = type->LLVMType(g->ctx);
-    llvm::Value *ptr = ctx->AllocaInst(llvmExprType, "print_arg");
+    llvm::Value *ptr = ctx->AllocaInst(llvmExprType, "print_arg")->getPointer();
     llvm::Value *val = expr->GetValue(ctx);
     if (!val)
         return NULL;
@@ -3541,7 +3546,7 @@ std::vector<llvm::Value *> PrintStmt::getDoPrintArgs(FunctionEmitContext *ctx) c
         checkFormatString(format, nArgs, pos);
         // Allocate space for the array of pointers to values to be printed
         llvm::Type *argPtrArrayType = llvm::ArrayType::get(LLVMTypes::VoidPointerType, nArgs);
-        llvm::Value *argPtrArray = ctx->AllocaInst(argPtrArrayType, "print_arg_ptrs");
+        llvm::Value *argPtrArray = ctx->AllocaInst(argPtrArrayType, "print_arg_ptrs")->getPointer();
         // Store the array pointer as a void **, which is what __do_print()
         // expects
         doPrintArgs[ARGS_IDX] = ctx->BitCastInst(argPtrArray, llvm::PointerType::get(LLVMTypes::VoidPointerType, 0));
diff --git a/src/sym.cpp b/src/sym.cpp
index c142847..9e73c99 100644
--- a/src/sym.cpp
+++ b/src/sym.cpp
@@ -49,7 +49,6 @@ using namespace ispc;
 // Symbol
 
 Symbol::Symbol(const std::string &n, SourcePos p, const Type *t, StorageClass sc) : pos(p), name(n) {
-    storagePtr = NULL;
     storageInfo = NULL;
     function = exportedFunction = NULL;
     type = t;
diff --git a/src/sym.h b/src/sym.h
index b8ffc71..b4c1886 100644
--- a/src/sym.h
+++ b/src/sym.h
@@ -70,11 +70,6 @@ class Symbol {
 
     SourcePos pos;            /*!< Source file position where the symbol was defined */
     std::string name;         /*!< Symbol's name */
-    llvm::Value *storagePtr;  /*!< For symbols with storage associated with
-                                   them (i.e. variables but not functions),
-                                   this member stores a pointer to its
-                                   location in memory.)
-                                   DEPRECATED. Use storageInfo instead. */
     AddressInfo *storageInfo; /*!< For symbols with storage associated with
                                    them (i.e. variables but not functions),
                                    this member stores an address info: pointer to
@@ -96,7 +91,7 @@ class Symbol {
                                     example, the ConstExpr class can't currently represent
                                     struct types.  For cases like these, ConstExpr is NULL,
                                     though for all const symbols, the value pointed to by the
-                                    storagePtr member will be its constant value.  (This
+                                    storageInfo pointer member will be its constant value.  (This
                                     messiness is due to needing an ispc ConstExpr for the early
                                     constant folding optimizations). */
     StorageClass storageClass; /*!< Records the storage class (if any) provided with the
-- 
2.38.0

