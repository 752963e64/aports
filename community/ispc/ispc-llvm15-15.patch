From 934302535a74be56b78c5da56e5a8bf5d1dc5955 Mon Sep 17 00:00:00 2001
From: Arina Neshlyaeva <arina.neshlyaeva@intel.com>
Date: Wed, 7 Sep 2022 16:05:18 -0700
Subject: [PATCH] Use AddressInfo in StoreInst and InitSymbol

Modified to work
---
 src/ctx.cpp  |  96 ++++++++++++++++++++---------------------
 src/ctx.h    |   2 +-
 src/expr.cpp | 119 +++++++++++++++++++++++++++------------------------
 src/expr.h   |   3 +-
 src/func.cpp |  24 +++++------
 src/stmt.cpp | 108 +++++++++++++++++++++++-----------------------
 6 files changed, 181 insertions(+), 171 deletions(-)

diff --git a/src/ctx.cpp b/src/ctx.cpp
index 9999f74..08a6ed7 100644
--- a/src/ctx.cpp
+++ b/src/ctx.cpp
@@ -256,7 +256,7 @@ FunctionEmitContext::FunctionEmitContext(Function *func, Symbol *funSym, llvm::F
     funcStartPos = funSym->pos;
 
     internalMaskAddressInfo = AllocaInst(LLVMTypes::MaskType, "internal_mask_memory");
-    StoreInst(LLVMMaskAllOn, internalMaskAddressInfo->getPointer());
+    StoreInst(LLVMMaskAllOn, internalMaskAddressInfo);
 
     // If the function doesn't have __mask in parameters, there is no need to
     // have function mask
@@ -268,7 +268,7 @@ FunctionEmitContext::FunctionEmitContext(Function *func, Symbol *funSym, llvm::F
     } else {
         functionMaskValue = LLVMMaskAllOn;
         fullMaskAddressInfo = AllocaInst(LLVMTypes::MaskType, "full_mask_memory");
-        StoreInst(LLVMMaskAllOn, fullMaskAddressInfo->getPointer());
+        StoreInst(LLVMMaskAllOn, fullMaskAddressInfo);
     }
 
     blockEntryMask = NULL;
@@ -281,11 +281,11 @@ FunctionEmitContext::FunctionEmitContext(Function *func, Symbol *funSym, llvm::F
     nextBlocks = NULL;
 
     returnedLanesAddressInfo = AllocaInst(LLVMTypes::MaskType, "returned_lanes_memory");
-    StoreInst(LLVMMaskAllOff, returnedLanesAddressInfo->getPointer());
+    StoreInst(LLVMMaskAllOff, returnedLanesAddressInfo);
 
     launchedTasks = false;
     launchGroupHandleAddressInfo = AllocaInst(LLVMTypes::VoidPointerType, "launch_group_handle");
-    StoreInst(llvm::Constant::getNullValue(LLVMTypes::VoidPointerType), launchGroupHandleAddressInfo->getPointer());
+    StoreInst(llvm::Constant::getNullValue(LLVMTypes::VoidPointerType), launchGroupHandleAddressInfo);
 
     disableGSWarningCount = 0;
 
@@ -444,17 +444,17 @@ void FunctionEmitContext::SetFunctionMask(llvm::Value *value) {
     if (fullMaskAddressInfo != NULL) {
         functionMaskValue = value;
         if (bblock != NULL)
-            StoreInst(GetFullMask(), fullMaskAddressInfo->getPointer());
+            StoreInst(GetFullMask(), fullMaskAddressInfo);
     }
 }
 
 void FunctionEmitContext::SetBlockEntryMask(llvm::Value *value) { blockEntryMask = value; }
 
 void FunctionEmitContext::SetInternalMask(llvm::Value *value) {
-    StoreInst(value, internalMaskAddressInfo->getPointer());
+    StoreInst(value, internalMaskAddressInfo);
     // kludge so that __mask returns the right value in ispc code.
     if (fullMaskAddressInfo)
-        StoreInst(GetFullMask(), fullMaskAddressInfo->getPointer());
+        StoreInst(GetFullMask(), fullMaskAddressInfo);
 }
 
 void FunctionEmitContext::SetInternalMaskAnd(llvm::Value *oldMask, llvm::Value *test) {
@@ -577,9 +577,9 @@ void FunctionEmitContext::StartLoop(llvm::BasicBlock *bt, llvm::BasicBlock *ct,
         // For loops with varying conditions, allocate space to store masks
         // that record which lanes have done these
         continueLanesAddressInfo = AllocaInst(LLVMTypes::MaskType, "continue_lanes_memory");
-        StoreInst(LLVMMaskAllOff, continueLanesAddressInfo->getPointer());
+        StoreInst(LLVMMaskAllOff, continueLanesAddressInfo);
         breakLanesAddressInfo = AllocaInst(LLVMTypes::MaskType, "break_lanes_memory");
-        StoreInst(LLVMMaskAllOff, breakLanesAddressInfo->getPointer());
+        StoreInst(LLVMMaskAllOff, breakLanesAddressInfo);
     }
 
     breakTarget = bt;
@@ -628,7 +628,7 @@ void FunctionEmitContext::StartForeach(ForeachType ft, bool isEmulatedUniform) {
     continueLanesAddressInfo = NULL;
     if (!isEmulatedUniform) {
         continueLanesAddressInfo = AllocaInst(LLVMTypes::MaskType, "foreach_continue_lanes");
-        StoreInst(LLVMMaskAllOff, continueLanesAddressInfo->getPointer());
+        StoreInst(LLVMMaskAllOff, continueLanesAddressInfo);
     }
 
     continueTarget = NULL; // should be set by SetContinueTarget()
@@ -707,7 +707,7 @@ void FunctionEmitContext::Break(bool doCoherenceCheck) {
         llvm::Value *mask = GetInternalMask();
         llvm::Value *breakMask = LoadInst(breakLanesAddressInfo->getPointer(), NULL, "break_mask");
         llvm::Value *newMask = BinaryOperator(llvm::Instruction::Or, mask, breakMask, "mask|break_mask");
-        StoreInst(newMask, breakLanesAddressInfo->getPointer());
+        StoreInst(newMask, breakLanesAddressInfo);
 
         // Set the current mask to be all off, just in case there are any
         // statements in the same scope after the 'break'.  Most of time
@@ -765,7 +765,7 @@ void FunctionEmitContext::Continue(bool doCoherenceCheck) {
         llvm::Value *mask = GetInternalMask();
         llvm::Value *continueMask = LoadInst(continueLanesAddressInfo->getPointer(), NULL, "continue_mask");
         llvm::Value *newMask = BinaryOperator(llvm::Instruction::Or, mask, continueMask, "mask|continueMask");
-        StoreInst(newMask, continueLanesAddressInfo->getPointer());
+        StoreInst(newMask, continueLanesAddressInfo);
 
         // And set the current mask to be all off in case there are any
         // statements in the same scope after the 'continue'
@@ -853,7 +853,7 @@ void FunctionEmitContext::RestoreContinuedLanes() {
     SetInternalMask(orMask);
 
     // continueLanes = 0
-    StoreInst(LLVMMaskAllOff, continueLanesAddressInfo->getPointer());
+    StoreInst(LLVMMaskAllOff, continueLanesAddressInfo);
 }
 
 void FunctionEmitContext::ClearBreakLanes() {
@@ -861,7 +861,7 @@ void FunctionEmitContext::ClearBreakLanes() {
         return;
 
     // breakLanes = 0
-    StoreInst(LLVMMaskAllOff, breakLanesAddressInfo->getPointer());
+    StoreInst(LLVMMaskAllOff, breakLanesAddressInfo);
 }
 
 void FunctionEmitContext::StartSwitch(bool cfIsUniform, llvm::BasicBlock *bbBreak, bool isEmulatedUniform) {
@@ -872,7 +872,7 @@ void FunctionEmitContext::StartSwitch(bool cfIsUniform, llvm::BasicBlock *bbBrea
                                                 defaultBlock, caseBlocks, nextBlocks, switchConditionWasUniform));
 
     breakLanesAddressInfo = AllocaInst(LLVMTypes::MaskType, "break_lanes_memory");
-    StoreInst(LLVMMaskAllOff, breakLanesAddressInfo->getPointer());
+    StoreInst(LLVMMaskAllOff, breakLanesAddressInfo);
     breakTarget = bbBreak;
 
     continueLanesAddressInfo = NULL;
@@ -1077,7 +1077,7 @@ void FunctionEmitContext::EmitCaseLabel(int value, bool checkMask, SourcePos pos
             // EM will be restored after this branch.
             // We need to skip case check for lanes that are
             // turned on at this point.
-            StoreInst(XeSimdCFPredicate(LLVMMaskAllOn), switchFallThroughMaskAddressInfo->getPointer());
+            StoreInst(XeSimdCFPredicate(LLVMMaskAllOn), switchFallThroughMaskAddressInfo);
         }
 
         if (emitXeHardwareMask() && !inXeSimdCF()) {
@@ -1182,7 +1182,7 @@ void FunctionEmitContext::SwitchInst(llvm::Value *expr, llvm::BasicBlock *bbDefa
         if (emitXeHardwareMask()) {
             // Init fall through mask
             switchFallThroughMaskAddressInfo = AllocaInst(LLVMTypes::MaskType, "fall_through_mask");
-            StoreInst(LLVMMaskAllOff, switchFallThroughMaskAddressInfo->getPointer());
+            StoreInst(LLVMMaskAllOff, switchFallThroughMaskAddressInfo);
         } else {
             // For a varying switch, we first turn off all lanes of the mask
             SetInternalMask(LLVMMaskAllOff);
@@ -1279,7 +1279,7 @@ void FunctionEmitContext::CurrentLanesReturned(Expr *expr, bool doCoherenceCheck
             llvm::Value *retVal = expr->GetValue(this);
             if (retVal != NULL) {
                 if (returnType->IsUniformType() || CastType<ReferenceType>(returnType) != NULL)
-                    StoreInst(retVal, returnValueAddressInfo->getPointer(), returnType, returnType->IsUniformType());
+                    StoreInst(retVal, returnValueAddressInfo, returnType, returnType->IsUniformType());
                 else {
                     // Use a masked store to store the value of the expression
                     // in the return value memory; this preserves the return
@@ -1326,7 +1326,7 @@ void FunctionEmitContext::CurrentLanesReturned(Expr *expr, bool doCoherenceCheck
         // Otherwise update returnedLanesAddressInfo and turn off all of the lanes
         // in the current mask so that any subsequent statements in the
         // same scope after the return have no effect
-        StoreInst(newReturnedLanes, returnedLanesAddressInfo->getPointer());
+        StoreInst(newReturnedLanes, returnedLanesAddressInfo);
         AddInstrumentationPoint("return: some but not all lanes have returned");
         SetInternalMask(LLVMMaskAllOff);
     }
@@ -2819,7 +2819,7 @@ void FunctionEmitContext::maskedStore(llvm::Value *value, llvm::Value *ptr, cons
         llvm::Value *maskedOld = BinaryOperator(llvm::Instruction::And, old, notMask, "old&~mask");
         llvm::Value *maskedNew = BinaryOperator(llvm::Instruction::And, value, mask, "new&mask");
         llvm::Value *final = BinaryOperator(llvm::Instruction::Or, maskedOld, maskedNew, "old_new_result");
-        StoreInst(final, ptr, valueType);
+        StoreInst(final, new AddressInfo(ptr, llvmValueStorageType), valueType);
         return;
     } else if (llvmValueStorageType == LLVMTypes::DoubleVectorType) {
         maskedStoreFunc = m->module->getFunction("__pseudo_masked_store_double");
@@ -2970,16 +2970,16 @@ void FunctionEmitContext::scatter(llvm::Value *value, llvm::Value *ptr, const Ty
         addGSMetadata(inst, currentPos);
 }
 
-void FunctionEmitContext::StoreInst(llvm::Value *value, llvm::Value *ptr, const Type *ptrType, bool isUniformData) {
-    if (value == NULL || ptr == NULL) {
+void FunctionEmitContext::StoreInst(llvm::Value *value, AddressInfo *ptrInfo, const Type *ptrType, bool isUniformData) {
+    if (value == NULL || ptrInfo == NULL) {
         // may happen due to error elsewhere
         AssertPos(currentPos, m->errorCount > 0);
         return;
     }
+    llvm::Value *ptr = ptrInfo->getPointer();
 
     llvm::PointerType *pt = llvm::dyn_cast<llvm::PointerType>(ptr->getType());
     AssertPos(currentPos, pt != NULL);
-
     if ((ptrType != NULL) && (ptrType->IsBoolType())) {
         if ((CastType<AtomicType>(ptrType) != NULL)) {
             value = SwitchBoolSize(value, ptrType->LLVMStorageType(g->ctx));
@@ -2993,7 +2993,7 @@ void FunctionEmitContext::StoreInst(llvm::Value *value, llvm::Value *ptr, const
 
     llvm::StoreInst *inst = new llvm::StoreInst(value, ptr, bblock);
 
-    if (g->opt.forceAlignedMemory && llvm::dyn_cast<llvm::VectorType>(pt->PTR_ELT_TYPE())) {
+    if (g->opt.forceAlignedMemory && llvm::dyn_cast<llvm::VectorType>(ptrInfo->getElementType())) {
         inst->setAlignment(llvm::MaybeAlign(g->target->getNativeVectorAlignment()).valueOrOne());
     }
 
@@ -3019,6 +3019,7 @@ void FunctionEmitContext::StoreInst(llvm::Value *value, llvm::Value *ptr, llvm::
     }
 
     const PointerType *ptrType = RegularizePointer(ptrRefType);
+    AddressInfo *ptrInfo = new AddressInfo(ptr, ptrType);
 
     if (CastType<UndefinedStructType>(ptrType->GetBaseType())) {
         Error(currentPos, "Unable to store to undefined struct type \"%s\".",
@@ -3033,11 +3034,11 @@ void FunctionEmitContext::StoreInst(llvm::Value *value, llvm::Value *ptr, llvm::
             storeUniformToSOA(value, ptr, mask, valueType, ptrType);
         else if (ptrType->GetBaseType()->IsUniformType())
             // the easy case
-            StoreInst(value, ptr, valueType, true);
+            StoreInst(value, ptrInfo, valueType, true);
         else if (mask == LLVMMaskAllOn && !g->opt.disableMaskAllOnOptimizations)
             // Otherwise it is a masked store unless we can determine that the
             // mask is all on...  (Unclear if this check is actually useful.)
-            StoreInst(value, ptr, valueType, false);
+            StoreInst(value, ptrInfo, valueType, false);
         else {
             maskedStore(value, ptr, ptrType, mask);
         }
@@ -3070,7 +3071,7 @@ void FunctionEmitContext::storeUniformToSOA(llvm::Value *value, llvm::Value *ptr
         // then we can do a final regular store
         AssertPos(currentPos, Type::IsBasicType(valueType));
         ptr = lFinalSliceOffset(this, ptr, &ptrType);
-        StoreInst(value, ptr, valueType, valueType->IsUniformType());
+        StoreInst(value, new AddressInfo(ptr, ptrType), valueType, valueType->IsUniformType());
     }
 }
 
@@ -3418,25 +3419,25 @@ llvm::Value *FunctionEmitContext::CallInst(llvm::Value *func, const FunctionType
         Assert(funcType != NULL);
         const Type *returnType = funcType->GetReturnType();
         llvm::Type *llvmReturnType = returnType->LLVMType(g->ctx);
-        llvm::Value *resultPtr = NULL;
+        AddressInfo *resultPtrInfo = NULL;
         if (llvmReturnType->isVoidTy() == false)
-            resultPtr = AllocaInst(returnType)->getPointer();
+            resultPtrInfo = AllocaInst(returnType);
 
         // The memory pointed to by maskPointer tracks the set of program
         // instances for which we still need to call the function they are
         // pointing to.  It starts out initialized with the mask of
         // currently running program instances.
         llvm::Value *oldFullMask = NULL;
-        llvm::Value *maskPtr = AllocaInst(LLVMTypes::MaskType)->getPointer();
+        AddressInfo *maskPtrInfo = AllocaInst(LLVMTypes::MaskType);
         if (emitXeHardwareMask()) {
 #ifdef ISPC_XE_ENABLED
             // Current mask will be calculated according to EM mask
             oldFullMask = XeSimdCFPredicate(LLVMMaskAllOn);
-            StoreInst(oldFullMask, maskPtr, NULL, true);
+            StoreInst(oldFullMask, maskPtrInfo, NULL, true);
 #endif
         } else {
             oldFullMask = GetFullMask();
-            StoreInst(oldFullMask, maskPtr);
+            StoreInst(oldFullMask, maskPtrInfo);
         }
 
         // Mask wasn't initialized
@@ -3450,7 +3451,7 @@ llvm::Value *FunctionEmitContext::CallInst(llvm::Value *func, const FunctionType
         // bbCall
         SetCurrentBasicBlock(bbTest);
         {
-            llvm::Value *maskLoad = LoadInst(maskPtr);
+            llvm::Value *maskLoad = LoadInst(maskPtrInfo->getPointer());
             llvm::Value *any = Any(maskLoad);
             BranchInst(bbCall, bbDone, any);
         }
@@ -3461,7 +3462,7 @@ llvm::Value *FunctionEmitContext::CallInst(llvm::Value *func, const FunctionType
         {
             // Figure out the first lane that still needs its function
             // pointer to be called.
-            llvm::Value *currentMask = LoadInst(maskPtr);
+            llvm::Value *currentMask = LoadInst(maskPtrInfo->getPointer());
             llvm::Function *cttz = m->module->getFunction("__count_trailing_zeros_i64");
             AssertPos(currentPos, cttz != NULL);
             llvm::Value *firstLane64 = CallInst(cttz, NULL, LaneMask(currentMask), "first_lane64");
@@ -3514,15 +3515,16 @@ llvm::Value *FunctionEmitContext::CallInst(llvm::Value *func, const FunctionType
             // Now, do a masked store into the memory allocated to
             // accumulate the result using the call mask.
             if (callResult != NULL && callResult->getType() != LLVMTypes::VoidType) {
-                AssertPos(currentPos, resultPtr != NULL);
+                AssertPos(currentPos, resultPtrInfo != NULL);
                 if (emitXeHardwareMask()) {
                     // This store will be predicated during SIMD CF Lowering
-                    StoreInst(callResult, resultPtr);
+                    StoreInst(callResult, resultPtrInfo);
                 } else {
-                    StoreInst(callResult, resultPtr, callMask, returnType, PointerType::GetUniform(returnType));
+                    StoreInst(callResult, resultPtrInfo->getPointer(), callMask, returnType,
+                              PointerType::GetUniform(returnType));
                 }
             } else
-                AssertPos(currentPos, resultPtr == NULL);
+                AssertPos(currentPos, resultPtrInfo == NULL);
 
             if (emitXeHardwareMask()) {
                 // Finish SIMDCall BB
@@ -3536,9 +3538,9 @@ llvm::Value *FunctionEmitContext::CallInst(llvm::Value *func, const FunctionType
             llvm::Value *notCallMask = BinaryOperator(llvm::Instruction::Xor, callMask, LLVMMaskAllOn, "~callMask");
             currentMask = BinaryOperator(llvm::Instruction::And, currentMask, notCallMask, "currentMask&~callMask");
             if (emitXeHardwareMask()) {
-                StoreInst(currentMask, maskPtr, NULL, true);
+                StoreInst(currentMask, maskPtrInfo, NULL, true);
             } else {
-                StoreInst(currentMask, maskPtr);
+                StoreInst(currentMask, maskPtrInfo);
             }
 
             // And go back to the test to see if we need to do another
@@ -3550,7 +3552,7 @@ llvm::Value *FunctionEmitContext::CallInst(llvm::Value *func, const FunctionType
         // accumulated in the result memory.
         SetCurrentBasicBlock(bbDone);
         SetInternalMask(origMask);
-        return resultPtr ? LoadInst(resultPtr, funcType->GetReturnType()) : NULL;
+        return resultPtrInfo ? LoadInst(resultPtrInfo->getPointer(), funcType->GetReturnType()) : NULL;
     }
 }
 
@@ -3632,8 +3634,6 @@ llvm::Value *FunctionEmitContext::LaunchInst(llvm::Value *callee, std::vector<ll
 
     llvm::PointerType *pt = llvm::dyn_cast<llvm::PointerType>(argType);
     AssertPos(currentPos, pt);
-    AssertPos(currentPos, llvm::StructType::classof(pt->PTR_ELT_TYPE()));
-
     std::vector<llvm::Type *> llvmArgTypes = funcType->LLVMFunctionArgTypes(g->ctx);
     llvm::StructType *argStructType = llvm::StructType::get(*g->ctx, llvmArgTypes);
     AssertPos(currentPos, argStructType != NULL);
@@ -3659,14 +3659,14 @@ llvm::Value *FunctionEmitContext::LaunchInst(llvm::Value *callee, std::vector<ll
     for (unsigned int i = 0; i < argVals.size(); ++i) {
         llvm::Value *ptr = AddElementOffset(argmem, i, NULL, "funarg");
         // don't need to do masked store here, I think
-        StoreInst(argVals[i], ptr);
+        StoreInst(argVals[i], new AddressInfo(ptr, llvmArgTypes[i]));
     }
 
     if (argStructType->getNumElements() == argVals.size() + 1) {
         // copy in the mask
         llvm::Value *mask = GetFullMask();
         llvm::Value *ptr = AddElementOffset(argmem, argVals.size(), NULL, "funarg_mask");
-        StoreInst(mask, ptr);
+        StoreInst(mask, new AddressInfo(ptr, LLVMTypes::MaskType));
     }
 
     // And emit the call to the user-supplied task launch function, passing
@@ -3706,7 +3706,7 @@ void FunctionEmitContext::SyncInst() {
 
     // zero out the handle so that if ISPCLaunch is called again in this
     // function, it knows it's starting out from scratch
-    StoreInst(nullPtrValue, launchGroupHandleAddressInfo->getPointer());
+    StoreInst(nullPtrValue, launchGroupHandleAddressInfo);
 
     BranchInst(bPostSync);
 
@@ -3853,10 +3853,10 @@ llvm::Value *FunctionEmitContext::XePrepareVectorBranch(llvm::Value *value) {
 llvm::Value *FunctionEmitContext::XeStartUnmaskedRegion() {
     auto Fn = llvm::GenXIntrinsic::getGenXDeclaration(m->module, llvm::GenXIntrinsic::genx_unmask_begin);
     std::vector<llvm::Value *> args;
-    llvm::Value *maskAlloca = AllocaInst(LLVMTypes::Int32Type)->getPointer();
+    AddressInfo *maskAlloca = AllocaInst(LLVMTypes::Int32Type);
     llvm::Value *execMask = llvm::CallInst::Create(Fn, args, "", bblock);
     StoreInst(execMask, maskAlloca);
-    return maskAlloca;
+    return maskAlloca->getPointer();
 }
 
 void FunctionEmitContext::XeEndUnmaskedRegion(llvm::Value *execMask) {
diff --git a/src/ctx.h b/src/ctx.h
index 96ab348..4299f81 100644
--- a/src/ctx.h
+++ b/src/ctx.h
@@ -525,7 +525,7 @@ class FunctionEmitContext {
         single pointer, not a varying lvalue.
         'ptrType' needs to be provided when storage type is different from IR type. For example,
      * 'unform bool' is 'i1' in IR but stored as 'i8'. */
-    void StoreInst(llvm::Value *value, llvm::Value *ptr, const Type *ptrType = NULL, bool isUniformData = false);
+    void StoreInst(llvm::Value *value, AddressInfo *ptrInfo, const Type *ptrType = NULL, bool isUniformData = false);
 
     /** In this variant of StoreInst(), the lvalue may be varying.  If so,
         this corresponds to a scatter.  Whether the lvalue is uniform of
diff --git a/src/expr.cpp b/src/expr.cpp
index 0e5927f..32a3fd0 100644
--- a/src/expr.cpp
+++ b/src/expr.cpp
@@ -611,7 +611,7 @@ bool ispc::PossiblyResolveFunctionOverloads(Expr *expr, const Type *type) {
     @param ctx       FunctionEmitContext to use for generating instructions
     @param pos       Source file position of the variable being initialized
 */
-void ispc::InitSymbol(llvm::Value *ptr, const Type *symType, Expr *initExpr, FunctionEmitContext *ctx, SourcePos pos) {
+void ispc::InitSymbol(AddressInfo *ptrInfo, const Type *symType, Expr *initExpr, FunctionEmitContext *ctx, SourcePos pos) {
     if (initExpr == NULL)
         // leave it uninitialized
         return;
@@ -633,13 +633,13 @@ void ispc::InitSymbol(llvm::Value *ptr, const Type *symType, Expr *initExpr, Fun
         }
 
         if (Type::IsBasicType(symType))
-            ctx->StoreInst(constValue, ptr, symType, symType->IsUniformType());
+            ctx->StoreInst(constValue, ptrInfo, symType, symType->IsUniformType());
         else {
             llvm::Value *constPtr =
                 new llvm::GlobalVariable(*m->module, llvmType, true /* const */, llvm::GlobalValue::InternalLinkage,
                                          constValue, "const_initializer");
             llvm::Value *size = g->target->SizeOf(llvmType, ctx->GetCurrentBasicBlock());
-            ctx->MemcpyInst(ptr, constPtr, size);
+            ctx->MemcpyInst(ptrInfo->getPointer(), constPtr, size);
         }
 
         return;
@@ -659,7 +659,8 @@ void ispc::InitSymbol(llvm::Value *ptr, const Type *symType, Expr *initExpr, Fun
         llvm::Value *initializerValue = initExpr->GetValue(ctx);
         if (initializerValue != NULL)
             // Bingo; store the value in the variable's storage
-            ctx->StoreInst(initializerValue, ptr, symType, symType->IsUniformType());
+            ctx->StoreInst(initializerValue, ptrInfo, symType,
+                           symType->IsUniformType());
         return;
     }
 
@@ -670,7 +671,7 @@ void ispc::InitSymbol(llvm::Value *ptr, const Type *symType, Expr *initExpr, Fun
         ExprList *elist = llvm::dyn_cast<ExprList>(initExpr);
         if (elist != NULL) {
             if (elist->exprs.size() == 1) {
-                InitSymbol(ptr, symType, elist->exprs[0], ctx, pos);
+                InitSymbol(ptrInfo, symType, elist->exprs[0], ctx, pos);
                 return;
             } else if (symType->IsVaryingType() == false) {
                 Error(initExpr->pos,
@@ -695,7 +696,8 @@ void ispc::InitSymbol(llvm::Value *ptr, const Type *symType, Expr *initExpr, Fun
 
         llvm::Value *initializerValue = initExpr->GetValue(ctx);
         if (initializerValue)
-            ctx->StoreInst(initializerValue, ptr, initExpr->GetType(), symType->IsUniformType());
+            ctx->StoreInst(initializerValue, ptrInfo, initExpr->GetType(),
+                           symType->IsUniformType());
         return;
     }
 
@@ -758,13 +760,13 @@ void ispc::InitSymbol(llvm::Value *ptr, const Type *symType, Expr *initExpr, Fun
 
                 llvm::Value *ep;
                 if (CastType<StructType>(symType) != NULL)
-                    ep = ctx->AddElementOffset(ptr, i, NULL, "element");
+                    ep = ctx->AddElementOffset(ptrInfo->getPointer(), i, NULL, "element");
                 else
-                    ep = ctx->GetElementPtrInst(ptr, LLVMInt32(0), LLVMInt32(i), PointerType::GetUniform(elementType),
+                    ep = ctx->GetElementPtrInst(ptrInfo->getPointer(), LLVMInt32(0), LLVMInt32(i), PointerType::GetUniform(elementType),
                                                 "gep");
-
+                AddressInfo* epInfo = new AddressInfo(ep, ptrInfo->getElementType());
                 if (i < nInits)
-                    InitSymbol(ep, elementType, exprList->exprs[i], ctx, pos);
+                    InitSymbol(epInfo, elementType, exprList->exprs[i], ctx, pos);
                 else {
                     // If we don't have enough initializer values, initialize the
                     // rest as zero.
@@ -775,7 +777,7 @@ void ispc::InitSymbol(llvm::Value *ptr, const Type *symType, Expr *initExpr, Fun
                     }
 
                     llvm::Constant *zeroInit = llvm::Constant::getNullValue(llvmType);
-                    ctx->StoreInst(zeroInit, ep, elementType, elementType->IsUniformType());
+                    ctx->StoreInst(zeroInit, epInfo, elementType, elementType->IsUniformType());
                 }
             }
         } else if (collectionType) {
@@ -1747,7 +1749,7 @@ llvm::Value *lEmitLogicalOp(BinaryExpr::Op op, Expr *arg0, Expr *arg1, FunctionE
         AssertPos(pos, m->errorCount > 0);
         return NULL;
     }
-    llvm::Value *retPtr = ctx->AllocaInst(retType, "logical_op_mem")->getPointer();
+    AddressInfo *retPtrInfo = ctx->AllocaInst(retType, "logical_op_mem");
     llvm::BasicBlock *bbSkipEvalValue1 = ctx->CreateBasicBlock("skip_eval_1", ctx->GetCurrentBasicBlock());
     llvm::BasicBlock *bbEvalValue1 = ctx->CreateBasicBlock("eval_1", bbSkipEvalValue1);
     llvm::BasicBlock *bbLogicalDone = ctx->CreateBasicBlock("logical_op_done", bbEvalValue1);
@@ -1772,7 +1774,7 @@ llvm::Value *lEmitLogicalOp(BinaryExpr::Op op, Expr *arg0, Expr *arg1, FunctionE
             // uniform or varying)
             ctx->SetCurrentBasicBlock(bbSkipEvalValue1);
             llvm::Value *trueValue = retType->IsUniformType() ? LLVMTrue : LLVMMaskAllOn;
-            ctx->StoreInst(trueValue, retPtr, retType, retType->IsUniformType());
+            ctx->StoreInst(trueValue, retPtrInfo, retType, retType->IsUniformType());
             ctx->BranchInst(bbLogicalDone);
         } else {
             AssertPos(pos, op == BinaryExpr::LogicalAnd);
@@ -1785,7 +1787,7 @@ llvm::Value *lEmitLogicalOp(BinaryExpr::Op op, Expr *arg0, Expr *arg1, FunctionE
             // uniform or varying false).
             ctx->SetCurrentBasicBlock(bbSkipEvalValue1);
             llvm::Value *falseValue = retType->IsUniformType() ? LLVMFalse : LLVMMaskAllOff;
-            ctx->StoreInst(falseValue, retPtr, retType, retType->IsUniformType());
+            ctx->StoreInst(falseValue, retPtrInfo, retType, retType->IsUniformType());
             ctx->BranchInst(bbLogicalDone);
         }
 
@@ -1804,14 +1806,14 @@ llvm::Value *lEmitLogicalOp(BinaryExpr::Op op, Expr *arg0, Expr *arg1, FunctionE
             AssertPos(pos, m->errorCount > 0);
             return NULL;
         }
-        ctx->StoreInst(value1, retPtr, arg1->GetType(), retType->IsUniformType());
+        ctx->StoreInst(value1, retPtrInfo, arg1->GetType(), retType->IsUniformType());
         ctx->BranchInst(bbLogicalDone);
 
         // In all cases, we end up at the bbLogicalDone basic block;
         // loading the value stored in retPtr in turn gives the overall
         // result.
         ctx->SetCurrentBasicBlock(bbLogicalDone);
-        return ctx->LoadInst(retPtr, retType);
+        return ctx->LoadInst(retPtrInfo->getPointer(), retType);
     } else {
         // Otherwise, the first operand is varying...  Save the current
         // value of the mask so that we can restore it at the end.
@@ -1845,7 +1847,7 @@ llvm::Value *lEmitLogicalOp(BinaryExpr::Op op, Expr *arg0, Expr *arg1, FunctionE
             // value0 is true for all running lanes, so it can be used for
             // the final result
             ctx->SetCurrentBasicBlock(bbSkipEvalValue1);
-            ctx->StoreInst(value0, retPtr, arg0->GetType(), retType->IsUniformType());
+            ctx->StoreInst(value0, retPtrInfo, arg0->GetType(), retType->IsUniformType());
             ctx->BranchInst(bbLogicalDone);
 
             // Otherwise, we need to valuate arg1. However, first we need
@@ -1869,7 +1871,7 @@ llvm::Value *lEmitLogicalOp(BinaryExpr::Op op, Expr *arg0, Expr *arg1, FunctionE
             llvm::Value *value1AndMask =
                 ctx->BinaryOperator(llvm::Instruction::And, value1, ctx->GetInternalMask(), "op&mask");
             llvm::Value *result = ctx->BinaryOperator(llvm::Instruction::Or, value0AndMask, value1AndMask, "or_result");
-            ctx->StoreInst(result, retPtr, retType, retType->IsUniformType());
+            ctx->StoreInst(result, retPtrInfo, retType, retType->IsUniformType());
             ctx->BranchInst(bbLogicalDone);
         } else {
             AssertPos(pos, op == BinaryExpr::LogicalAnd);
@@ -1894,7 +1896,7 @@ llvm::Value *lEmitLogicalOp(BinaryExpr::Op op, Expr *arg0, Expr *arg1, FunctionE
             // value0 was false for all running lanes, so use its value as
             // the overall result.
             ctx->SetCurrentBasicBlock(bbSkipEvalValue1);
-            ctx->StoreInst(value0, retPtr, arg0->GetType(), retType->IsUniformType());
+            ctx->StoreInst(value0, retPtrInfo, arg0->GetType(), retType->IsUniformType());
             ctx->BranchInst(bbLogicalDone);
 
             // Otherwise we need to evaluate value1, but again with the
@@ -1918,7 +1920,7 @@ llvm::Value *lEmitLogicalOp(BinaryExpr::Op op, Expr *arg0, Expr *arg1, FunctionE
                 ctx->BinaryOperator(llvm::Instruction::And, value1, ctx->GetInternalMask(), "value1&mask");
             llvm::Value *result =
                 ctx->BinaryOperator(llvm::Instruction::And, value0AndMask, value1AndMask, "or_result");
-            ctx->StoreInst(result, retPtr, retType, retType->IsUniformType());
+            ctx->StoreInst(result, retPtrInfo, retType, retType->IsUniformType());
             ctx->BranchInst(bbLogicalDone);
         }
 
@@ -1926,7 +1928,7 @@ llvm::Value *lEmitLogicalOp(BinaryExpr::Op op, Expr *arg0, Expr *arg1, FunctionE
         // the old mask and return the computed result
         ctx->SetCurrentBasicBlock(bbLogicalDone);
         ctx->SetInternalMask(oldMask);
-        return ctx->LoadInst(retPtr, retType);
+        return ctx->LoadInst(retPtrInfo->getPointer(), retType);
     }
 }
 
@@ -3269,18 +3271,18 @@ SelectExpr::SelectExpr(Expr *t, Expr *e1, Expr *e2, SourcePos p) : Expr(p, Selec
 static llvm::Value *lEmitVaryingSelect(FunctionEmitContext *ctx, llvm::Value *test, llvm::Value *expr1,
                                        llvm::Value *expr2, const Type *type) {
 
-    llvm::Value *resultPtr = ctx->AllocaInst(type, "selectexpr_tmp")->getPointer();
-    Assert(resultPtr != NULL);
+    AddressInfo *resultPtrInfo = ctx->AllocaInst(type, "selectexpr_tmp");
+    Assert(resultPtrInfo != NULL);
     // Don't need to worry about masking here
-    ctx->StoreInst(expr2, resultPtr, type, type->IsUniformType());
+    ctx->StoreInst(expr2, resultPtrInfo, type, type->IsUniformType());
     // Use masking to conditionally store the expr1 values
-    Assert(resultPtr->getType() == PointerType::GetUniform(type)->LLVMStorageType(g->ctx));
-    ctx->StoreInst(expr1, resultPtr, test, type, PointerType::GetUniform(type));
-    return ctx->LoadInst(resultPtr, type, "selectexpr_final");
+    Assert(resultPtrInfo->getType() == PointerType::GetUniform(type)->LLVMStorageType(g->ctx));
+    ctx->StoreInst(expr1, resultPtrInfo->getPointer(), test, type, PointerType::GetUniform(type));
+    return ctx->LoadInst(resultPtrInfo->getPointer(), type, "selectexpr_final");
 }
 
 static void lEmitSelectExprCode(FunctionEmitContext *ctx, llvm::Value *testVal, llvm::Value *oldMask,
-                                llvm::Value *fullMask, Expr *expr, llvm::Value *exprPtr) {
+                                llvm::Value *fullMask, Expr *expr, AddressInfo *exprPtrInfo) {
     llvm::BasicBlock *bbEval = ctx->CreateBasicBlock("select_eval_expr", ctx->GetCurrentBasicBlock());
     llvm::BasicBlock *bbDone = ctx->CreateBasicBlock("select_done", bbEval);
 
@@ -3294,7 +3296,7 @@ static void lEmitSelectExprCode(FunctionEmitContext *ctx, llvm::Value *testVal,
     llvm::Value *testAndMask = ctx->BinaryOperator(llvm::Instruction::And, testVal, oldMask, "test&mask");
     ctx->SetInternalMask(testAndMask);
     llvm::Value *exprVal = expr->GetValue(ctx);
-    ctx->StoreInst(exprVal, exprPtr, expr->GetType(), expr->GetType()->IsUniformType());
+    ctx->StoreInst(exprVal, exprPtrInfo, expr->GetType(), expr->GetType()->IsUniformType());
     ctx->BranchInst(bbDone);
 
     ctx->SetCurrentBasicBlock(bbDone);
@@ -3393,29 +3395,29 @@ llvm::Value *SelectExpr::GetValue(FunctionEmitContext *ctx) const {
         // Temporary storage to store the values computed for each
         // expression, if any.  (These stay as uninitialized memory if we
         // short circuit around the corresponding expression.)
-        llvm::Value *expr1Ptr = ctx->AllocaInst(expr1->GetType())->getPointer();
-        llvm::Value *expr2Ptr = ctx->AllocaInst(expr1->GetType())->getPointer();
+        AddressInfo *expr1PtrInfo = ctx->AllocaInst(expr1->GetType());
+        AddressInfo *expr2PtrInfo = ctx->AllocaInst(expr1->GetType());
 
         if (shortCircuit1)
-            lEmitSelectExprCode(ctx, testVal, oldMask, fullMask, expr1, expr1Ptr);
+            lEmitSelectExprCode(ctx, testVal, oldMask, fullMask, expr1, expr1PtrInfo);
         else {
             ctx->SetInternalMaskAnd(oldMask, testVal);
             llvm::Value *expr1Val = expr1->GetValue(ctx);
-            ctx->StoreInst(expr1Val, expr1Ptr, expr1->GetType(), expr1->GetType()->IsUniformType());
+            ctx->StoreInst(expr1Val, expr1PtrInfo, expr1->GetType(), expr1->GetType()->IsUniformType());
         }
 
         if (shortCircuit2) {
             llvm::Value *notTest = ctx->NotOperator(testVal);
-            lEmitSelectExprCode(ctx, notTest, oldMask, fullMask, expr2, expr2Ptr);
+            lEmitSelectExprCode(ctx, notTest, oldMask, fullMask, expr2, expr2PtrInfo);
         } else {
             ctx->SetInternalMaskAndNot(oldMask, testVal);
             llvm::Value *expr2Val = expr2->GetValue(ctx);
-            ctx->StoreInst(expr2Val, expr2Ptr, expr2->GetType(), expr2->GetType()->IsUniformType());
+            ctx->StoreInst(expr2Val, expr2PtrInfo, expr2->GetType(), expr2->GetType()->IsUniformType());
         }
 
         ctx->SetInternalMask(oldMask);
-        llvm::Value *expr1Val = ctx->LoadInst(expr1Ptr, expr1->GetType());
-        llvm::Value *expr2Val = ctx->LoadInst(expr2Ptr, expr2->GetType());
+        llvm::Value *expr1Val = ctx->LoadInst(expr1PtrInfo->getPointer(), expr1->GetType());
+        llvm::Value *expr2Val = ctx->LoadInst(expr2PtrInfo->getPointer(), expr2->GetType());
         return lEmitVaryingSelect(ctx, testVal, expr1Val, expr2Val, type);
     } else {
         // FIXME? Short-circuiting doesn't work in the case of
@@ -4350,8 +4352,8 @@ llvm::Value *IndexExpr::GetValue(FunctionEmitContext *ctx) const {
             return NULL;
         }
         ctx->SetDebugPos(pos);
-        llvm::Value *tmpPtr = ctx->AllocaInst(baseExprType, "array_tmp")->getPointer();
-        ctx->StoreInst(val, tmpPtr, baseExprType, baseExprType->IsUniformType());
+        AddressInfo *tmpPtrInfo = ctx->AllocaInst(baseExprType, "array_tmp");
+        ctx->StoreInst(val, tmpPtrInfo, baseExprType, baseExprType->IsUniformType());
 
         // Get a pointer type to the underlying elements
         const SequentialType *st = CastType<SequentialType>(baseExprType);
@@ -4362,7 +4364,8 @@ llvm::Value *IndexExpr::GetValue(FunctionEmitContext *ctx) const {
         lvType = PointerType::GetUniform(st->GetElementType());
 
         // And do the indexing calculation into the temporary array in memory
-        ptr = ctx->GetElementPtrInst(tmpPtr, LLVMInt32(0), index->GetValue(ctx), PointerType::GetUniform(baseExprType));
+        ptr = ctx->GetElementPtrInst(tmpPtrInfo->getPointer(), LLVMInt32(0), index->GetValue(ctx),
+                                     PointerType::GetUniform(baseExprType));
         ptr = lAddVaryingOffsetsIfNeeded(ctx, ptr, lvType);
 
         mask = LLVMMaskAllOn;
@@ -5013,6 +5016,7 @@ llvm::Value *VectorMemberExpr::GetValue(FunctionEmitContext *ctx) const {
         }
 
         llvm::Value *basePtr = NULL;
+        AddressInfo *basePtrInfo = NULL;
         const Type *basePtrType = NULL;
         if (dereferenceExpr) {
             basePtr = expr->GetValue(ctx);
@@ -5025,19 +5029,20 @@ llvm::Value *VectorMemberExpr::GetValue(FunctionEmitContext *ctx) const {
         if (basePtr == NULL || basePtrType == NULL) {
             // Check that expression on the left side is a rvalue expression
             llvm::Value *exprValue = expr->GetValue(ctx);
-            basePtr = ctx->AllocaInst(expr->GetType())->getPointer();
+            basePtrInfo = ctx->AllocaInst(expr->GetType());
+            basePtr = basePtrInfo->getPointer();
             basePtrType = PointerType::GetUniform(exprVectorType);
             if (basePtr == NULL || basePtrType == NULL) {
                 AssertPos(pos, m->errorCount > 0);
                 return NULL;
             }
-            ctx->StoreInst(exprValue, basePtr, expr->GetType(), expr->GetType()->IsUniformType());
+            ctx->StoreInst(exprValue, basePtrInfo, expr->GetType(), expr->GetType()->IsUniformType());
         }
 
         // Allocate temporary memory to store the result
-        llvm::Value *resultPtr = ctx->AllocaInst(memberType, "vector_tmp")->getPointer();
+        AddressInfo *resultPtrInfo = ctx->AllocaInst(memberType, "vector_tmp");
 
-        if (resultPtr == NULL) {
+        if (resultPtrInfo == NULL) {
             AssertPos(pos, m->errorCount > 0);
             return NULL;
         }
@@ -5060,11 +5065,15 @@ llvm::Value *VectorMemberExpr::GetValue(FunctionEmitContext *ctx) const {
                 ctx->AddElementOffset(basePtr, indices[i], basePtrType, llvm::Twine(basePtr->getName()) + idStr);
             llvm::Value *elementValue = ctx->LoadInst(elementPtr, elementMask, elementPtrType);
 
-            llvm::Value *ptmp = ctx->AddElementOffset(resultPtr, i, NULL, llvm::Twine(resultPtr->getName()) + idStr);
-            ctx->StoreInst(elementValue, ptmp, elementPtrType, expr->GetType()->IsUniformType());
+            llvm::Value *ptmp = ctx->AddElementOffset(resultPtrInfo->getPointer(), i, NULL,
+                                                      llvm::Twine(resultPtrInfo->getPointer()->getName()) + idStr);
+            // TODO: when we have swizzle on bool type, it breaks here on StoreInst.
+            // The condition in StoreInst checking that SwitchBoolSize is needed doesn't detect it.
+            ctx->StoreInst(elementValue, new AddressInfo(ptmp, exprVectorType->GetElementType()), elementPtrType);
+
         }
 
-        return ctx->LoadInst(resultPtr, memberType, llvm::Twine(basePtr->getName()) + "_swizzle");
+        return ctx->LoadInst(resultPtrInfo->getPointer(), memberType, llvm::Twine(basePtr->getName()) + "_swizzle");
     }
 }
 
@@ -5182,14 +5191,14 @@ llvm::Value *MemberExpr::GetValue(FunctionEmitContext *ctx) const {
         }
         ctx->SetDebugPos(pos);
         const Type *exprType = expr->GetType();
-        llvm::Value *ptr = ctx->AllocaInst(exprType, "struct_tmp")->getPointer();
-        ctx->StoreInst(val, ptr, exprType, exprType->IsUniformType());
+        AddressInfo *ptrInfo = ctx->AllocaInst(exprType, "struct_tmp");
+        ctx->StoreInst(val, ptrInfo, exprType, exprType->IsUniformType());
 
         int elementNumber = getElementNumber();
         if (elementNumber == -1)
             return NULL;
 
-        lvalue = ctx->AddElementOffset(ptr, elementNumber, PointerType::GetUniform(exprType));
+        lvalue = ctx->AddElementOffset(ptrInfo->getPointer(), elementNumber, PointerType::GetUniform(exprType));
         lvalueType = PointerType::GetUniform(GetType());
         mask = LLVMMaskAllOn;
     } else {
@@ -7235,9 +7244,9 @@ llvm::Value *ReferenceExpr::GetValue(FunctionEmitContext *ctx) const {
         return NULL;
     }
 
-    llvm::Value *ptr = ctx->AllocaInst(type)->getPointer();
-    ctx->StoreInst(value, ptr, type, expr->GetType()->IsUniformType());
-    return ptr;
+    AddressInfo *ptrInfo = ctx->AllocaInst(type);
+    ctx->StoreInst(value, ptrInfo, type, expr->GetType()->IsUniformType());
+    return ptrInfo->getPointer();
 }
 
 Symbol *ReferenceExpr::GetBaseSymbol() const { return expr ? expr->GetBaseSymbol() : NULL; }
@@ -8391,7 +8400,7 @@ llvm::Value *NewExpr::GetValue(FunctionEmitContext *ctx) const {
                 ctx->SetCurrentBasicBlock(bbInit);
                 llvm::Type *ptrType = retType->GetAsUniformType()->LLVMType(g->ctx);
                 llvm::Value *ptr = ctx->IntToPtrInst(p, ptrType);
-                InitSymbol(ptr, allocType, initExpr, ctx, pos);
+                InitSymbol(new AddressInfo(ptr, ptrType), allocType, initExpr, ctx, pos);
                 ctx->BranchInst(bbSkip);
 
                 ctx->SetCurrentBasicBlock(bbSkip);
@@ -8407,7 +8416,7 @@ llvm::Value *NewExpr::GetValue(FunctionEmitContext *ctx) const {
         ptrValue = ctx->BitCastInst(ptrValue, ptrType, llvm::Twine(ptrValue->getName()) + "_cast_ptr");
 
         if (initExpr != NULL)
-            InitSymbol(ptrValue, allocType, initExpr, ctx, pos);
+            InitSymbol(new AddressInfo(ptrValue, ptrType), allocType, initExpr, ctx, pos);
 
         return ptrValue;
     }
diff --git a/src/expr.h b/src/expr.h
index 06d45e1..c7f1505 100644
--- a/src/expr.h
+++ b/src/expr.h
@@ -38,6 +38,7 @@
 #pragma once
 
 #include "ast.h"
+#include "ctx.h"
 #include "ispc.h"
 #include "type.h"
 
@@ -818,7 +819,7 @@ Expr *MakeBinaryExpr(BinaryExpr::Op o, Expr *a, Expr *b, SourcePos p);
     @param ctx       FunctionEmitContext to use for generating instructions
     @param pos       Source file position of the variable being initialized
 */
-void InitSymbol(llvm::Value *lvalue, const Type *symType, Expr *initExpr, FunctionEmitContext *ctx, SourcePos pos);
+void InitSymbol(AddressInfo *lvalue, const Type *symType, Expr *initExpr, FunctionEmitContext *ctx, SourcePos pos);
 
 bool PossiblyResolveFunctionOverloads(Expr *expr, const Type *type);
 } // namespace ispc
diff --git a/src/func.cpp b/src/func.cpp
index 9d1b20c..ba6e605 100644
--- a/src/func.cpp
+++ b/src/func.cpp
@@ -265,7 +265,7 @@ static void lCopyInTaskParameter(int i, AddressInfo *structArgPtrInfo, const std
     // and copy the value from the struct and into the local alloca'ed
     // memory
     llvm::Value *ptrval = ctx->LoadInst(ptr, sym->type, sym->name.c_str());
-    ctx->StoreInst(ptrval, sym->storageInfo->getPointer(), sym->type, sym->type->IsUniformType());
+    ctx->StoreInst(ptrval, sym->storageInfo, sym->type, sym->type->IsUniformType());
     ctx->EmitFunctionParameterDebugInfo(sym, i);
 }
 
@@ -334,32 +334,32 @@ void Function::emitCode(FunctionEmitContext *ctx, llvm::Function *function, Sour
         // Copy threadIndex and threadCount into stack-allocated storage so
         // that their symbols point to something reasonable.
         threadIndexSym->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "threadIndex");
-        ctx->StoreInst(threadIndex, threadIndexSym->storageInfo->getPointer());
+        ctx->StoreInst(threadIndex, threadIndexSym->storageInfo);
 
         threadCountSym->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "threadCount");
-        ctx->StoreInst(threadCount, threadCountSym->storageInfo->getPointer());
+        ctx->StoreInst(threadCount, threadCountSym->storageInfo);
 
         // Copy taskIndex and taskCount into stack-allocated storage so
         // that their symbols point to something reasonable.
         taskIndexSym->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskIndex");
-        ctx->StoreInst(taskIndex, taskIndexSym->storageInfo->getPointer());
+        ctx->StoreInst(taskIndex, taskIndexSym->storageInfo);
 
         taskCountSym->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskCount");
-        ctx->StoreInst(taskCount, taskCountSym->storageInfo->getPointer());
+        ctx->StoreInst(taskCount, taskCountSym->storageInfo);
 
         taskIndexSym0->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskIndex0");
-        ctx->StoreInst(taskIndex0, taskIndexSym0->storageInfo->getPointer());
+        ctx->StoreInst(taskIndex0, taskIndexSym0->storageInfo);
         taskIndexSym1->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskIndex1");
-        ctx->StoreInst(taskIndex1, taskIndexSym1->storageInfo->getPointer());
+        ctx->StoreInst(taskIndex1, taskIndexSym1->storageInfo);
         taskIndexSym2->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskIndex2");
-        ctx->StoreInst(taskIndex2, taskIndexSym2->storageInfo->getPointer());
+        ctx->StoreInst(taskIndex2, taskIndexSym2->storageInfo);
 
         taskCountSym0->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskCount0");
-        ctx->StoreInst(taskCount0, taskCountSym0->storageInfo->getPointer());
+        ctx->StoreInst(taskCount0, taskCountSym0->storageInfo);
         taskCountSym1->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskCount1");
-        ctx->StoreInst(taskCount1, taskCountSym1->storageInfo->getPointer());
+        ctx->StoreInst(taskCount1, taskCountSym1->storageInfo);
         taskCountSym2->storageInfo = ctx->AllocaInst(LLVMTypes::Int32Type, "taskCount2");
-        ctx->StoreInst(taskCount2, taskCountSym2->storageInfo->getPointer());
+        ctx->StoreInst(taskCount2, taskCountSym2->storageInfo);
     } else {
         // Regular, non-task function or GPU task
         llvm::Function::arg_iterator argIter = function->arg_begin();
@@ -383,7 +383,7 @@ void Function::emitCode(FunctionEmitContext *ctx, llvm::Function *function, Sour
                 addrCasted = ctx->AddrSpaceCast(&*argIter, AddressSpace::ispc_default, true);
             }
 
-            ctx->StoreInst(addrCasted, argSym->storageInfo->getPointer(), argSym->type);
+            ctx->StoreInst(addrCasted, argSym->storageInfo, argSym->type);
 
             ctx->EmitFunctionParameterDebugInfo(argSym, i);
         }
diff --git a/src/stmt.cpp b/src/stmt.cpp
index 0c61a72..f191783 100644
--- a/src/stmt.cpp
+++ b/src/stmt.cpp
@@ -243,7 +243,7 @@ void DeclStmt::EmitCode(FunctionEmitContext *ctx) const {
 
             // And then get it initialized...
             sym->parentFunction = ctx->GetFunction();
-            InitSymbol(sym->storageInfo->getPointer(), sym->type, initExpr, ctx, sym->pos);
+            InitSymbol(sym->storageInfo, sym->type, initExpr, ctx, sym->pos);
         }
     }
 }
@@ -1272,10 +1272,11 @@ static llvm::Constant *lCalculateDeltaForVaryingCounter(int dim, int nDims, cons
    uniformCounterPtr, compute the corresponding set of varying counter
    values for use within the loop body.
  */
-static llvm::Value *lUpdateVaryingCounter(int dim, int nDims, FunctionEmitContext *ctx, llvm::Value *uniformCounterPtr,
-                                          llvm::Value *varyingCounterPtr, const std::vector<int> &spans) {
+static llvm::Value *lUpdateVaryingCounter(int dim, int nDims, FunctionEmitContext *ctx,
+                                          AddressInfo *uniformCounterPtrInfo, AddressInfo *varyingCounterPtrInfo,
+                                          const std::vector<int> &spans) {
     // Smear the uniform counter value out to be varying
-    llvm::Value *counter = ctx->LoadInst(uniformCounterPtr);
+    llvm::Value *counter = ctx->LoadInst(uniformCounterPtrInfo->getPointer());
     llvm::Value *smearCounter = ctx->BroadcastValue(counter, LLVMTypes::Int32VectorType, "smear_counter");
 
     llvm::Constant *delta = lCalculateDeltaForVaryingCounter(dim, nDims, spans);
@@ -1283,7 +1284,7 @@ static llvm::Value *lUpdateVaryingCounter(int dim, int nDims, FunctionEmitContex
     // Add the deltas to compute the varying counter values; store the
     // result to memory and then return it directly as well.
     llvm::Value *varyingCounter = ctx->BinaryOperator(llvm::Instruction::Add, smearCounter, delta, "iter_val");
-    ctx->StoreInst(varyingCounter, varyingCounterPtr);
+    ctx->StoreInst(varyingCounter, varyingCounterPtrInfo);
     return varyingCounter;
 }
 
@@ -1412,7 +1413,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         // dimension.  Its value is only used internally here for looping
         // logic and isn't directly available in the user's program code.
         uniformCounterPtrs.push_back(ctx->AllocaInst(LLVMTypes::Int32Type, "counter"));
-        ctx->StoreInst(startVals[i], uniformCounterPtrs[i]->getPointer());
+        ctx->StoreInst(startVals[i], uniformCounterPtrs[i]);
 
         // There is also a varying variable that holds the set of index
         // values for each dimension in the current loop iteration; this is
@@ -1426,7 +1427,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         // processed.  (i.e. this is used to disable the lanes that have
         // out-of-bounds offsets.)
         extrasMaskPtrs.push_back(ctx->AllocaInst(LLVMTypes::MaskType, "extras mask"));
-        ctx->StoreInst(LLVMMaskAllOn, extrasMaskPtrs[i]->getPointer());
+        ctx->StoreInst(LLVMMaskAllOn, extrasMaskPtrs[i]);
     }
 
     ctx->StartForeach(FunctionEmitContext::FOREACH_REGULAR);
@@ -1443,8 +1444,8 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         if (i == 0)
             ctx->BranchInst(bbExit);
         else {
-            ctx->StoreInst(LLVMMaskAllOn, extrasMaskPtrs[i]->getPointer());
-            ctx->StoreInst(startVals[i], uniformCounterPtrs[i]->getPointer());
+            ctx->StoreInst(LLVMMaskAllOn, extrasMaskPtrs[i]);
+            ctx->StoreInst(startVals[i], uniformCounterPtrs[i]);
             ctx->BranchInst(bbStep[i - 1]);
         }
     }
@@ -1460,7 +1461,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[i]->getPointer());
         llvm::Value *newCounter =
             ctx->BinaryOperator(llvm::Instruction::Add, counter, LLVMInt32(span[i]), "new_counter");
-        ctx->StoreInst(newCounter, uniformCounterPtrs[i]->getPointer());
+        ctx->StoreInst(newCounter, uniformCounterPtrs[i]);
         ctx->BranchInst(bbTest[i]);
     }
 
@@ -1483,8 +1484,8 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         else
             inExtras.push_back(ctx->BinaryOperator(llvm::Instruction::Or, inEx, inExtras[i - 1], "in_extras_all"));
 
-        llvm::Value *varyingCounter = lUpdateVaryingCounter(i, nDims, ctx, uniformCounterPtrs[i]->getPointer(),
-                                                            dimVariables[i]->storageInfo->getPointer(), span);
+        llvm::Value *varyingCounter =
+            lUpdateVaryingCounter(i, nDims, ctx, uniformCounterPtrs[i], dimVariables[i]->storageInfo, span);
 
         llvm::Value *smearEnd = ctx->BroadcastValue(endVals[i], LLVMTypes::Int32VectorType, "smear_end");
 
@@ -1494,11 +1495,11 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         emask = ctx->I1VecToBoolVec(emask);
 
         if (i == 0)
-            ctx->StoreInst(emask, extrasMaskPtrs[i]->getPointer());
+            ctx->StoreInst(emask, extrasMaskPtrs[i]);
         else {
             llvm::Value *oldMask = ctx->LoadInst(extrasMaskPtrs[i - 1]->getPointer());
             llvm::Value *newMask = ctx->BinaryOperator(llvm::Instruction::And, oldMask, emask, "extras_mask");
-            ctx->StoreInst(newMask, extrasMaskPtrs[i]->getPointer());
+            ctx->StoreInst(newMask, extrasMaskPtrs[i]);
         }
 
         llvm::Value *notAtEnd = ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_SLT, counter, endVals[i]);
@@ -1569,8 +1570,8 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     {
         // Update the varying counter value here, since all subsequent
         // blocks along this path need it.
-        lUpdateVaryingCounter(nDims - 1, nDims, ctx, uniformCounterPtrs[nDims - 1]->getPointer(),
-                              dimVariables[nDims - 1]->storageInfo->getPointer(), span);
+        lUpdateVaryingCounter(nDims - 1, nDims, ctx, uniformCounterPtrs[nDims - 1],
+                              dimVariables[nDims - 1]->storageInfo, span);
 
         // here we just check to see if counter < alignedEnd
         llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1]->getPointer(), NULL, "counter");
@@ -1585,7 +1586,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     // the innermost dimension but also when outer dimensions have set the
     // mask to be partially on.
     //
-    // The value stored in stepIndexAfterMaskedBodyPtr is used after each
+    // The value stored in stepIndexAfterMaskedBodyPtrInfo is used after each
     // execution of the body code to determine whether the innermost index
     // value should be incremented by the step (we're running the "for"
     // loop of full vectors at the innermost dimension, with outer
@@ -1595,7 +1596,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     // should step the loop counter for the next enclosing dimension
     // instead.
     // Revisit : Should this be an i1.
-    llvm::Value *stepIndexAfterMaskedBodyPtr = ctx->AllocaInst(LLVMTypes::BoolType, "step_index")->getPointer();
+    AddressInfo *stepIndexAfterMaskedBodyPtrInfo = ctx->AllocaInst(LLVMTypes::BoolType, "step_index");
 
     ///////////////////////////////////////////////////////////////////////////
     // We're in the inner loop part where the only masking is due to outer
@@ -1612,7 +1613,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
 
         ctx->SetInternalMask(mask);
 
-        ctx->StoreInst(LLVMTrue, stepIndexAfterMaskedBodyPtr);
+        ctx->StoreInst(LLVMTrue, stepIndexAfterMaskedBodyPtrInfo);
         ctx->BranchInst(bbMaskedBody);
     }
 
@@ -1636,7 +1637,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
             ctx->SetInternalMask(newMask);
         }
 
-        ctx->StoreInst(LLVMFalse, stepIndexAfterMaskedBodyPtr);
+        ctx->StoreInst(LLVMFalse, stepIndexAfterMaskedBodyPtrInfo);
 
         // check to see if counter != end, otherwise, the next step is not necessary
         llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1]->getPointer(), NULL, "counter");
@@ -1677,8 +1678,8 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     {
         ctx->SetInternalMask(LLVMMaskAllOn);
         ctx->SetBlockEntryMask(LLVMMaskAllOn);
-        lUpdateVaryingCounter(nDims - 1, nDims, ctx, uniformCounterPtrs[nDims - 1]->getPointer(),
-                              dimVariables[nDims - 1]->storageInfo->getPointer(), span);
+        lUpdateVaryingCounter(nDims - 1, nDims, ctx, uniformCounterPtrs[nDims - 1],
+                              dimVariables[nDims - 1]->storageInfo, span);
         ctx->SetContinueTarget(bbFullBodyContinue);
         ctx->AddInstrumentationPoint("foreach loop body (all on)");
         stmts->EmitCode(ctx);
@@ -1691,7 +1692,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1]->getPointer());
         llvm::Value *newCounter =
             ctx->BinaryOperator(llvm::Instruction::Add, counter, LLVMInt32(span[nDims - 1]), "new_counter");
-        ctx->StoreInst(newCounter, uniformCounterPtrs[nDims - 1]->getPointer());
+        ctx->StoreInst(newCounter, uniformCounterPtrs[nDims - 1]);
         ctx->BranchInst(bbOuterNotInExtras);
     }
 
@@ -1713,16 +1714,15 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     // mask for the innermost dimension
     ctx->SetCurrentBasicBlock(bbSetInnerMask);
     {
-        llvm::Value *varyingCounter =
-            lUpdateVaryingCounter(nDims - 1, nDims, ctx, uniformCounterPtrs[nDims - 1]->getPointer(),
-                                  dimVariables[nDims - 1]->storageInfo->getPointer(), span);
+        llvm::Value *varyingCounter = lUpdateVaryingCounter(nDims - 1, nDims, ctx, uniformCounterPtrs[nDims - 1],
+                                                            dimVariables[nDims - 1]->storageInfo, span);
         llvm::Value *smearEnd = ctx->BroadcastValue(endVals[nDims - 1], LLVMTypes::Int32VectorType, "smear_end");
         llvm::Value *emask = ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_SLT, varyingCounter, smearEnd);
         emask = ctx->I1VecToBoolVec(emask);
         ctx->SetInternalMask(emask);
         ctx->SetBlockEntryMask(emask);
 
-        ctx->StoreInst(LLVMFalse, stepIndexAfterMaskedBodyPtr);
+        ctx->StoreInst(LLVMFalse, stepIndexAfterMaskedBodyPtrInfo);
         ctx->BranchInst(bbMaskedBody);
     }
 
@@ -1747,7 +1747,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
     ctx->SetCurrentBasicBlock(bbMaskedBodyContinue);
     {
         ctx->RestoreContinuedLanes();
-        llvm::Value *stepIndex = ctx->LoadInst(stepIndexAfterMaskedBodyPtr);
+        llvm::Value *stepIndex = ctx->LoadInst(stepIndexAfterMaskedBodyPtrInfo->getPointer());
         ctx->BranchInst(bbStepInnerIndex, bbReset[nDims - 1], stepIndex);
     }
 
@@ -1759,7 +1759,7 @@ void ForeachStmt::EmitCode(FunctionEmitContext *ctx) const {
         llvm::Value *counter = ctx->LoadInst(uniformCounterPtrs[nDims - 1]->getPointer());
         llvm::Value *newCounter =
             ctx->BinaryOperator(llvm::Instruction::Add, counter, LLVMInt32(span[nDims - 1]), "new_counter");
-        ctx->StoreInst(newCounter, uniformCounterPtrs[nDims - 1]->getPointer());
+        ctx->StoreInst(newCounter, uniformCounterPtrs[nDims - 1]);
         ctx->BranchInst(bbOuterInExtras);
     }
 
@@ -1851,7 +1851,7 @@ void ForeachStmt::EmitCodeForXe(FunctionEmitContext *ctx) const {
         // Init vectorized counters
         dimVariables[i]->storageInfo = ctx->AllocaInst(LLVMTypes::Int32VectorType, dimVariables[i]->name.c_str());
         dimVariables[i]->parentFunction = ctx->GetFunction();
-        ctx->StoreInst(sv, dimVariables[i]->storageInfo->getPointer());
+        ctx->StoreInst(sv, dimVariables[i]->storageInfo);
         ctx->EmitVariableDebugInfo(dimVariables[i]);
     }
 
@@ -1872,7 +1872,7 @@ void ForeachStmt::EmitCodeForXe(FunctionEmitContext *ctx) const {
             ctx->BranchInst(bbExit);
         else {
             // Reset counter for this dimension, iterate over previous one
-            ctx->StoreInst(startVals[i], dimVariables[i]->storageInfo->getPointer());
+            ctx->StoreInst(startVals[i], dimVariables[i]->storageInfo);
             ctx->BranchInst(bbStep[i - 1]);
         }
     }
@@ -1884,7 +1884,7 @@ void ForeachStmt::EmitCodeForXe(FunctionEmitContext *ctx) const {
         ctx->SetCurrentBasicBlock(bbStep[i]);
         llvm::Value *counter = ctx->LoadInst(dimVariables[i]->storageInfo->getPointer());
         llvm::Value *newCounter = ctx->BinaryOperator(llvm::Instruction::Add, counter, steps[i], "new_counter");
-        ctx->StoreInst(newCounter, dimVariables[i]->storageInfo->getPointer());
+        ctx->StoreInst(newCounter, dimVariables[i]->storageInfo);
         ctx->BranchInst(bbTest[i]);
     }
 
@@ -2088,9 +2088,9 @@ void ForeachActiveStmt::EmitCode(FunctionEmitContext *ctx) const {
 #endif
         oldFullMask = ctx->GetFullMask();
 
-    llvm::Value *maskBitsPtr = ctx->AllocaInst(LLVMTypes::Int64Type, "mask_bits")->getPointer();
+    AddressInfo *maskBitsPtrInfo = ctx->AllocaInst(LLVMTypes::Int64Type, "mask_bits");
     llvm::Value *movmsk = ctx->LaneMask(oldFullMask);
-    ctx->StoreInst(movmsk, maskBitsPtr);
+    ctx->StoreInst(movmsk, maskBitsPtrInfo);
 
     // Officially start the loop.
     ctx->StartScope();
@@ -2103,7 +2103,7 @@ void ForeachActiveStmt::EmitCode(FunctionEmitContext *ctx) const {
     ctx->SetCurrentBasicBlock(bbFindNext);
     {
         // Load the bitmask of the lanes left to be processed
-        llvm::Value *remainingBits = ctx->LoadInst(maskBitsPtr, NULL, "remaining_bits");
+        llvm::Value *remainingBits = ctx->LoadInst(maskBitsPtrInfo->getPointer(), NULL, "remaining_bits");
 
         // Find the index of the first set bit in the mask
         llvm::Function *ctlzFunc = m->module->getFunction("__count_trailing_zeros_i64");
@@ -2112,7 +2112,7 @@ void ForeachActiveStmt::EmitCode(FunctionEmitContext *ctx) const {
 
         // Store that value into the storage allocated for the iteration
         // variable.
-        ctx->StoreInst(firstSet, sym->storageInfo->getPointer(), sym->type);
+        ctx->StoreInst(firstSet, sym->storageInfo, sym->type);
 
         // Now set the execution mask to be only on for the current program
         // instance.  (TODO: is there a more efficient way to do this? e.g.
@@ -2143,7 +2143,7 @@ void ForeachActiveStmt::EmitCode(FunctionEmitContext *ctx) const {
         llvm::Value *notSetMask = ctx->NotOperator(setMask);
         llvm::Value *newRemaining =
             ctx->BinaryOperator(llvm::Instruction::And, remainingBits, notSetMask, "new_remaining");
-        ctx->StoreInst(newRemaining, maskBitsPtr);
+        ctx->StoreInst(newRemaining, maskBitsPtrInfo);
 
         // and onward to run the loop body...
         // Set Xe EM through simdcf.goto
@@ -2174,7 +2174,7 @@ void ForeachActiveStmt::EmitCode(FunctionEmitContext *ctx) const {
         // statements normally, or a continue statement in the middle of
         // the loop that jumps to the end, see if there are any lanes left
         // to be processed.
-        llvm::Value *remainingBits = ctx->LoadInst(maskBitsPtr, NULL, "remaining_bits");
+        llvm::Value *remainingBits = ctx->LoadInst(maskBitsPtrInfo->getPointer(), NULL, "remaining_bits");
         llvm::Value *nonZero = ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_NE, remainingBits,
                                             LLVMInt64(0), "remaining_ne_zero");
         ctx->BranchInst(bbFindNext, bbDone, nonZero);
@@ -2287,9 +2287,9 @@ void ForeachUniqueStmt::EmitCode(FunctionEmitContext *ctx) const {
 #endif
         oldFullMask = ctx->GetFullMask();
 
-    llvm::Value *maskBitsPtr = ctx->AllocaInst(LLVMTypes::Int64Type, "mask_bits")->getPointer();
+    AddressInfo *maskBitsPtrInfo = ctx->AllocaInst(LLVMTypes::Int64Type, "mask_bits");
     llvm::Value *movmsk = ctx->LaneMask(oldFullMask);
-    ctx->StoreInst(movmsk, maskBitsPtr);
+    ctx->StoreInst(movmsk, maskBitsPtrInfo);
 
     // Officially start the loop.
     ctx->StartForeach(FunctionEmitContext::FOREACH_UNIQUE, emulatedUniform);
@@ -2307,7 +2307,7 @@ void ForeachUniqueStmt::EmitCode(FunctionEmitContext *ctx) const {
         return;
     }
     ctx->SetDebugPos(pos);
-    llvm::Value *exprMem = ctx->AllocaInst(exprType, "expr_mem")->getPointer();
+    AddressInfo *exprMem = ctx->AllocaInst(exprType, "expr_mem");
     ctx->StoreInst(exprValue, exprMem, exprType);
 
     // Onward to find the first set of lanes to run the loop for
@@ -2316,7 +2316,7 @@ void ForeachUniqueStmt::EmitCode(FunctionEmitContext *ctx) const {
     ctx->SetCurrentBasicBlock(bbFindNext);
     {
         // Load the bitmask of the lanes left to be processed
-        llvm::Value *remainingBits = ctx->LoadInst(maskBitsPtr, NULL, "remaining_bits");
+        llvm::Value *remainingBits = ctx->LoadInst(maskBitsPtrInfo->getPointer(), NULL, "remaining_bits");
 
         // Find the index of the first set bit in the mask
         llvm::Function *ctlzFunc = m->module->getFunction("__count_trailing_zeros_i64");
@@ -2329,7 +2329,7 @@ void ForeachUniqueStmt::EmitCode(FunctionEmitContext *ctx) const {
         // Load plus EEI is more preferable way to get unique value than GEP + load.
         // It allows better register utilization for Xe targets and reduces allocas
         // number for both CPU and Xe.
-        llvm::Value *uniqueValueVec = ctx->LoadInst(exprMem, exprType, "unique_value_vec");
+        llvm::Value *uniqueValueVec = ctx->LoadInst(exprMem->getPointer(), exprType, "unique_value_vec");
         Assert(llvm::dyn_cast<llvm::VectorType>(uniqueValueVec->getType()) != NULL);
         uniqueValue =
             llvm::ExtractElementInst::Create(uniqueValueVec, firstSet, "unique_value", ctx->GetCurrentBasicBlock());
@@ -2340,7 +2340,7 @@ void ForeachUniqueStmt::EmitCode(FunctionEmitContext *ctx) const {
         Assert(uniqueValue != NULL);
         // Store that value in sym's storage so that the iteration variable
         // has the right value inside the loop body
-        ctx->StoreInst(uniqueValue, sym->storageInfo->getPointer(), sym->type);
+        ctx->StoreInst(uniqueValue, sym->storageInfo, sym->type);
 
         // Set the execution mask so that it's on for any lane that a) was
         // running at the start of the foreach loop, and b) where that
@@ -2372,7 +2372,7 @@ void ForeachUniqueStmt::EmitCode(FunctionEmitContext *ctx) const {
         llvm::Value *notLoopMaskMM = ctx->NotOperator(loopMaskMM);
         llvm::Value *newRemaining =
             ctx->BinaryOperator(llvm::Instruction::And, remainingBits, notLoopMaskMM, "new_remaining");
-        ctx->StoreInst(newRemaining, maskBitsPtr);
+        ctx->StoreInst(newRemaining, maskBitsPtrInfo);
 
         // and onward...
         // Set Xe EM through simdcf.goto
@@ -2402,7 +2402,7 @@ void ForeachUniqueStmt::EmitCode(FunctionEmitContext *ctx) const {
         // the loop that jumps to the end, see if there are any lanes left
         // to be processed.
         ctx->RestoreContinuedLanes();
-        llvm::Value *remainingBits = ctx->LoadInst(maskBitsPtr, NULL, "remaining_bits");
+        llvm::Value *remainingBits = ctx->LoadInst(maskBitsPtrInfo->getPointer(), NULL, "remaining_bits");
         llvm::Value *nonZero = ctx->CmpInst(llvm::Instruction::ICmp, llvm::CmpInst::ICMP_NE, remainingBits,
                                             LLVMInt64(0), "remaining_ne_zero");
         ctx->BranchInst(bbFindNext, bbDone, nonZero);
@@ -3494,18 +3494,18 @@ void PrintStmt::emitCode4LZ(FunctionEmitContext *ctx) const {
     expression and store the result to alloca's memory.  Update the
     argTypes string with the type encoding for this expression.
  */
-static llvm::Value *lEmitPrintArgCode(Expr *expr, FunctionEmitContext *ctx) {
+static AddressInfo *lEmitPrintArgCode(Expr *expr, FunctionEmitContext *ctx) {
     const Type *type = expr->GetType();
 
     llvm::Type *llvmExprType = type->LLVMType(g->ctx);
-    llvm::Value *ptr = ctx->AllocaInst(llvmExprType, "print_arg")->getPointer();
+    AddressInfo *ptrInfo = ctx->AllocaInst(llvmExprType, "print_arg");
     llvm::Value *val = expr->GetValue(ctx);
     if (!val)
         return NULL;
-    ctx->StoreInst(val, ptr);
+    ctx->StoreInst(val, ptrInfo);
 
-    ptr = ctx->BitCastInst(ptr, LLVMTypes::VoidPointerType);
-    return ptr;
+    llvm::Value *ptr = ctx->BitCastInst(ptrInfo->getPointer(), LLVMTypes::VoidPointerType);
+    return new AddressInfo(ptr, LLVMTypes::VoidPointerType);
 }
 
 static bool lProcessPrintArg(Expr *expr, FunctionEmitContext *ctx, llvm::Value *argPtrArray, int offset,
@@ -3518,11 +3518,11 @@ static bool lProcessPrintArg(Expr *expr, FunctionEmitContext *ctx, llvm::Value *
     if (!expr)
         return false;
     argTypes.push_back(type);
-    llvm::Value *ptr = lEmitPrintArgCode(expr, ctx);
-    if (!ptr)
+    AddressInfo *ptrInfo = lEmitPrintArgCode(expr, ctx);
+    if (!ptrInfo)
         return false;
     llvm::Value *arrayPtr = ctx->AddElementOffset(argPtrArray, offset, NULL);
-    ctx->StoreInst(ptr, arrayPtr);
+    ctx->StoreInst(ptrInfo->getPointer(), new AddressInfo(arrayPtr, ptrInfo->getElementType()));
     return true;
 }
 
-- 
2.38.0

