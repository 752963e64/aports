From 0aa2e2e667fd9f59c95f532ac56277f4e4c63bf7 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Thu, 21 Oct 2021 08:24:24 -0400
Subject: [PATCH 01/20] expose tsig secrets via dnsserver.Config

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 core/dnsserver/config.go   |  4 ++++
 core/dnsserver/register.go |  1 +
 core/dnsserver/server.go   | 13 +++++++++++--
 3 files changed, 16 insertions(+), 2 deletions(-)

diff --git a/core/dnsserver/config.go b/core/dnsserver/config.go
index e5200d67cd..de72e702b3 100644
--- a/core/dnsserver/config.go
+++ b/core/dnsserver/config.go
@@ -6,6 +6,7 @@ import (
	"net/http"

	"github.com/coredns/caddy"
+
	"github.com/coredns/coredns/plugin"
 )

@@ -40,6 +41,9 @@ type Config struct {
	// TLSConfig when listening for encrypted connections (gRPC, DNS-over-TLS).
	TLSConfig *tls.Config

+	// TSIG secrets per zone
+	TsigSecret map[string]string
+
	// Plugin stack.
	Plugin []plugin.Plugin

diff --git a/core/dnsserver/register.go b/core/dnsserver/register.go
index ec254085ed..1930fa0f55 100644
--- a/core/dnsserver/register.go
+++ b/core/dnsserver/register.go
@@ -155,6 +155,7 @@ func (h *dnsContext) MakeServers() ([]caddy.Server, error) {
		c.ListenHosts = c.firstConfigInBlock.ListenHosts
		c.Debug = c.firstConfigInBlock.Debug
		c.TLSConfig = c.firstConfigInBlock.TLSConfig
+		c.TsigSecret = c.firstConfigInBlock.TsigSecret
	}

	// we must map (group) each config to a bind address
diff --git a/core/dnsserver/server.go b/core/dnsserver/server.go
index 9b0a20b3cf..8f904b87fb 100644
--- a/core/dnsserver/server.go
+++ b/core/dnsserver/server.go
@@ -11,6 +11,7 @@ import (
	"time"

	"github.com/coredns/caddy"
+
	"github.com/coredns/coredns/plugin"
	"github.com/coredns/coredns/plugin/metrics/vars"
	"github.com/coredns/coredns/plugin/pkg/edns"
@@ -42,6 +43,8 @@ type Server struct {
	trace        trace.Trace        // the trace plugin for the server
	debug        bool               // disable recover()
	classChaos   bool               // allow non-INET class queries
+
+	tsigSecret map[string]string
}

 // NewServer returns a new CoreDNS server and compiles all plugins in to it. By default CH class
@@ -52,6 +55,7 @@ func NewServer(addr string, group []*Config) (*Server, error) {
		Addr:         addr,
		zones:        make(map[string]*Config),
		graceTimeout: 5 * time.Second,
+		tsigSecret: make(map[string]string),
	}

	// We have to bound our wg with one increment
@@ -70,6 +74,11 @@ func NewServer(addr string, group []*Config) (*Server, error) {
		// set the config per zone
		s.zones[site.Zone] = site

+		// copy tsig secrets
+		for zone, secret := range site.TsigSecret {
+			s.tsigSecret[zone] = secret
+		}
+
		// compile custom plugin for everything
		var stack plugin.Handler
		for i := len(site.Plugin) - 1; i >= 0; i-- {
@@ -112,7 +121,7 @@ func (s *Server) Serve(l net.Listener) error {
		ctx := context.WithValue(context.Background(), Key{}, s)
		ctx = context.WithValue(ctx, LoopKey{}, 0)
		s.ServeDNS(ctx, w, r)
-	})}
+	}), TsigSecret: s.tsigSecret}
	s.m.Unlock()

	return s.server[tcp].ActivateAndServe()
@@ -126,7 +135,7 @@ func (s *Server) ServePacket(p net.PacketConn) error {
		ctx := context.WithValue(context.Background(), Key{}, s)
		ctx = context.WithValue(ctx, LoopKey{}, 0)
		s.ServeDNS(ctx, w, r)
-	})}
+	}), TsigSecret: s.tsigSecret}
	s.m.Unlock()

	return s.server[udp].ActivateAndServe()

From fd2571fc4139ef4e5ffdccca54797078f8e44638 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Tue, 2 Nov 2021 14:23:26 -0400
Subject: [PATCH 02/20] tsig plugin

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 core/dnsserver/config.go      |   2 +-
 core/dnsserver/server.go      |   4 +-
 core/dnsserver/zdirectives.go |   1 +
 core/plugin/zplugin.go        |   1 +
 plugin.cfg                    |   1 +
 plugin/tsig/README.md         |  56 ++++++++++++
 plugin/tsig/setup.go          |  85 ++++++++++++++++++
 plugin/tsig/setup_test.go     | 135 ++++++++++++++++++++++++++++
 plugin/tsig/tsig.go           | 114 ++++++++++++++++++++++++
 plugin/tsig/tsig_test.go      | 160 ++++++++++++++++++++++++++++++++++
 10 files changed, 556 insertions(+), 3 deletions(-)
 create mode 100644 plugin/tsig/README.md
 create mode 100644 plugin/tsig/setup.go
 create mode 100644 plugin/tsig/setup_test.go
 create mode 100644 plugin/tsig/tsig.go
 create mode 100644 plugin/tsig/tsig_test.go

diff --git a/core/dnsserver/config.go b/core/dnsserver/config.go
index de72e702b3..efee10489f 100644
--- a/core/dnsserver/config.go
+++ b/core/dnsserver/config.go
@@ -41,7 +41,7 @@ type Config struct {
	// TLSConfig when listening for encrypted connections (gRPC, DNS-over-TLS).
	TLSConfig *tls.Config

-	// TSIG secrets per zone
+	// TSIG secrets, [name]key
	TsigSecret map[string]string

	// Plugin stack.
diff --git a/core/dnsserver/server.go b/core/dnsserver/server.go
index 8f904b87fb..1c0d662803 100644
--- a/core/dnsserver/server.go
+++ b/core/dnsserver/server.go
@@ -75,8 +75,8 @@ func NewServer(addr string, group []*Config) (*Server, error) {
		s.zones[site.Zone] = site

		// copy tsig secrets
-		for zone, secret := range site.TsigSecret {
-			s.tsigSecret[zone] = secret
+		for key, secret := range site.TsigSecret {
+			s.tsigSecret[key] = secret
		}

		// compile custom plugin for everything
diff --git a/core/dnsserver/zdirectives.go b/core/dnsserver/zdirectives.go
index bca217185f..53168be869 100644
--- a/core/dnsserver/zdirectives.go
+++ b/core/dnsserver/zdirectives.go
@@ -34,6 +34,7 @@ var Directives = []string{
	"any",
	"chaos",
	"loadbalance",
+	"tsig",
	"cache",
	"rewrite",
	"header",
diff --git a/core/plugin/zplugin.go b/core/plugin/zplugin.go
index a9167eeaf6..45bfb5415e 100644
--- a/core/plugin/zplugin.go
+++ b/core/plugin/zplugin.go
@@ -52,5 +52,6 @@ import (
	_ "github.com/coredns/coredns/plugin/tls"
	_ "github.com/coredns/coredns/plugin/trace"
	_ "github.com/coredns/coredns/plugin/transfer"
+	_ "github.com/coredns/coredns/plugin/tsig"
	_ "github.com/coredns/coredns/plugin/whoami"
)
diff --git a/plugin.cfg b/plugin.cfg
index 628e714129..46a7df4c1d 100644
--- a/plugin.cfg
+++ b/plugin.cfg
@@ -43,6 +43,7 @@ acl:acl
 any:any
 chaos:chaos
 loadbalance:loadbalance
+tsig:tsig
 cache:cache
 rewrite:rewrite
 header:header
diff --git a/plugin/tsig/README.md b/plugin/tsig/README.md
new file mode 100644
index 0000000000..9d560d0d6c
--- /dev/null
+++ b/plugin/tsig/README.md
@@ -0,0 +1,56 @@
+# tsig
+
+## Name
+
+*tsig* - validate TSIG requests and sign responses.
+
+## Description
+
+With *tsig*, you can define a set of TSIG secret keys for validating incoming TSIG requests and signing
+responses. It can also require TSIG for certain query types, refusing requests that do not comply.
+
+## Syntax
+
+~~~
+tsig [ZONE...] {
+  secret NAME KEY
+  require [QTYPE...]
+}
+~~~
+
+   * **ZONE** - the zones *tsig* will TSIG.  By default, the zones from the server block are used.
+
+   * `secret` **KEY** - specifies a TSIG secret for **NAME** with **KEY**. Use this option more than once
+   to define multiple secrets. Secrets are global to the server instance, not just for the enclosing **ZONE**.
+
+   * `require` **QTYPE...** - the query types that must be TSIG'd. Requests of the specified types
+   will be `REFUSED` if they are not signed.`require all` will require requests of all types to be
+   signed. `require none` will not require requests any types to be signed. Default behavior is to not require.
+
+## Examples
+
+Require TSIG signed transactions for transfer requests to `example.zone`.
+
+```
+example.zone {
+  tsig {
+    secret example.zone.key. NoTCJU+DMqFWywaPyxSijrDEA/eC3nK0xi3AMEZuPVk=
+    require AXFR IXFR
+  }
+  transfer {
+    to *
+  }
+}
+```
+
+Require TSIG signed transactions for all requests to `auth.zone`.
+
+```
+auth.zone {
+  tsig {
+    secret auth.zone.key. NoTCJU+DMqFWywaPyxSijrDEA/eC3nK0xi3AMEZuPVk=
+    require all
+  }
+  forward . 10.1.0.2
+}
+```
diff --git a/plugin/tsig/setup.go b/plugin/tsig/setup.go
new file mode 100644
index 0000000000..cfa0fc707a
--- /dev/null
+++ b/plugin/tsig/setup.go
@@ -0,0 +1,85 @@
+package tsig
+
+import (
+	"github.com/coredns/caddy"
+	"github.com/miekg/dns"
+
+	"github.com/coredns/coredns/core/dnsserver"
+	"github.com/coredns/coredns/plugin"
+)
+
+func init() {
+	caddy.RegisterPlugin(pluginName, caddy.Plugin{
+		ServerType: "dns",
+		Action:     setup,
+	})
+}
+
+func setup(c *caddy.Controller) error {
+	t, err := parse(c)
+	if err != nil {
+		return plugin.Error(pluginName, c.ArgErr())
+	}
+
+	config := dnsserver.GetConfig(c)
+
+	config.TsigSecret = t.secrets
+
+	config.AddPlugin(func(next plugin.Handler) plugin.Handler {
+		t.Next = next
+		return t
+	})
+
+	return nil
+}
+
+func parse(c *caddy.Controller) (*TSIGServer, error) {
+	t := &TSIGServer{
+		secrets: make(map[string]string),
+		types:   defaultQTypes,
+	}
+
+	for i := 0; c.Next(); i++ {
+		if i > 0 {
+			return nil, plugin.ErrOnce
+		}
+
+		t.Zones = plugin.OriginsFromArgsOrServerBlock(c.RemainingArgs(), c.ServerBlockKeys)
+		for c.NextBlock() {
+			switch c.Val() {
+			case "secret":
+				args := c.RemainingArgs()
+				if len(args) != 2 {
+					return nil, c.ArgErr()
+				}
+				t.secrets[args[0]] = args[1]
+			case "require":
+				t.types = qTypes{}
+				args := c.RemainingArgs()
+				if len(args) == 0 {
+					return nil, c.ArgErr()
+				}
+				if args[0] == "all" {
+					t.all = true
+					continue
+				}
+				if args[0] == "none" {
+					continue
+				}
+				for _, str := range args {
+					qt, ok := dns.StringToType[str]
+					if !ok {
+						return nil, c.Errf("unknown query type '%s'", str)
+					}
+					t.types[qt] = struct{}{}
+				}
+			default:
+				return nil, c.Errf("unknown property '%s'", c.Val())
+			}
+		}
+	}
+
+	return t, nil
+}
+
+var defaultQTypes = qTypes{}
\ No newline at end of file
diff --git a/plugin/tsig/setup_test.go b/plugin/tsig/setup_test.go
new file mode 100644
index 0000000000..ee49fd3a2c
--- /dev/null
+++ b/plugin/tsig/setup_test.go
@@ -0,0 +1,135 @@
+package tsig
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/coredns/caddy"
+	"github.com/miekg/dns"
+)
+
+func TestParse(t *testing.T) {
+
+	secrets := map[string]string{
+		"name.key.":  "test-key",
+		"name2.key.": "test-key-2",
+	}
+	secretConfig := ""
+	for k, s := range secrets {
+		secretConfig += fmt.Sprintf("secret %s %s\n", k, s)
+	}
+	tests := []struct {
+		input           string
+		shouldErr       bool
+		expectedZones   []string
+		expectedQTypes  qTypes
+		expectedSecrets map[string]string
+		expectedAll     bool
+	}{
+		{
+			input:           "tsig {\n " + secretConfig + "}",
+			expectedZones:   []string{"."},
+			expectedQTypes:  defaultQTypes,
+			expectedSecrets: secrets,
+		},
+		{
+			input:           "tsig example.com {\n " + secretConfig + "}",
+			expectedZones:   []string{"example.com."},
+			expectedQTypes:  defaultQTypes,
+			expectedSecrets: secrets,
+		},
+		{
+			input:           "tsig {\n " + secretConfig + " require all \n}",
+			expectedZones:   []string{"."},
+			expectedQTypes:  qTypes{},
+			expectedAll:     true,
+			expectedSecrets: secrets,
+		},
+		{
+			input:           "tsig {\n " + secretConfig + " require none \n}",
+			expectedZones:   []string{"."},
+			expectedQTypes:  qTypes{},
+			expectedAll:     false,
+			expectedSecrets: secrets,
+		},
+		{
+			input:           "tsig {\n " + secretConfig + " \n require A AAAA \n}",
+			expectedZones:   []string{"."},
+			expectedQTypes:  qTypes{dns.TypeA: {}, dns.TypeAAAA: {}},
+			expectedSecrets: secrets,
+		},
+		{
+			input:     "tsig {\n blah \n}",
+			shouldErr: true,
+		},
+		{
+			input:     "tsig {\n secret name. too many parameters \n}",
+			shouldErr: true,
+		},
+		{
+			input:     "tsig {\n require \n}",
+			shouldErr: true,
+		},
+		{
+			input:     "tsig {\n require invalid-qtype \n}",
+			shouldErr: true,
+		},
+	}
+
+	serverBlockKeys := []string{"."}
+	for i, test := range tests {
+		c := caddy.NewTestController("dns", test.input)
+		c.ServerBlockKeys = serverBlockKeys
+		ts, err := parse(c)
+
+		if err == nil && test.shouldErr {
+			t.Fatalf("Test %d expected errors, but got no error.", i)
+		} else if err != nil && !test.shouldErr {
+			t.Fatalf("Test %d expected no errors, but got '%v'", i, err)
+		}
+
+		if test.shouldErr {
+			continue
+		}
+
+		if len(test.expectedZones) != len(ts.Zones) {
+			t.Fatalf("Test %d expected zones '%v', but got '%v'.", i, test.expectedZones, ts.Zones)
+		}
+		for j := range test.expectedZones {
+			if test.expectedZones[j] != ts.Zones[j] {
+				t.Errorf("Test %d expected zones '%v', but got '%v'.", i, test.expectedZones, ts.Zones)
+				break
+			}
+		}
+
+		if test.expectedAll != ts.all {
+			t.Errorf("Test %d expected require all to be '%v', but got '%v'.", i, test.expectedAll, ts.all)
+		}
+
+		if len(test.expectedQTypes) != len(ts.types) {
+			t.Fatalf("Test %d expected required types '%v', but got '%v'.", i, test.expectedQTypes, ts.types)
+		}
+		for qt := range test.expectedQTypes {
+			if _, ok := ts.types[qt]; !ok {
+				t.Errorf("Test %d required types '%v', but got '%v'.", i, test.expectedQTypes, ts.types)
+				break
+			}
+		}
+
+		if len(test.expectedSecrets) != len(ts.secrets) {
+			t.Fatalf("Test %d expected secrets '%v', but got '%v'.", i, test.expectedSecrets, ts.secrets)
+		}
+		for qt := range test.expectedSecrets {
+			secret, ok := ts.secrets[qt]
+			if !ok {
+				t.Errorf("Test %d required secrets '%v', but got '%v'.", i, test.expectedSecrets, ts.secrets)
+				break
+			}
+			if secret != ts.secrets[qt] {
+				t.Errorf("Test %d required secrets '%v', but got '%v'.", i, test.expectedSecrets, ts.secrets)
+				break
+			}
+		}
+
+	}
+}
diff --git a/plugin/tsig/tsig.go b/plugin/tsig/tsig.go
new file mode 100644
index 0000000000..53c64e2a99
--- /dev/null
+++ b/plugin/tsig/tsig.go
@@ -0,0 +1,114 @@
+package tsig
+
+import (
+	"context"
+	"fmt"
+
+	"github.com/miekg/dns"
+
+	"github.com/coredns/coredns/plugin"
+	"github.com/coredns/coredns/plugin/pkg/log"
+	"github.com/coredns/coredns/request"
+)
+
+type TSIGServer struct {
+	Zones   []string
+	secrets map[string]string // [key-name]secret
+	types   qTypes
+	all     bool
+	Next    plugin.Handler
+}
+
+type qTypes map[uint16]struct{}
+
+func (t TSIGServer) Name() string { return pluginName }
+
+type restoreTsigWriter struct {
+	dns.ResponseWriter
+	req     *dns.Msg  // original request excluding TSIG if it has one
+	reqTSIG *dns.TSIG // original TSIG
+}
+
+func (r *restoreTsigWriter) WriteMsg(m *dns.Msg) error {
+	// Make sure the response has an EDNS OPT RR if the request had it.
+	// Otherwise ScrubWriter would append it *after* TSIG, making it a non-compliant DNS message.
+	state := request.Request{Req: r.req, W: r.ResponseWriter}
+	state.SizeAndDo(m)
+
+	if r.reqTSIG != nil {
+		var repTSIG dns.TSIG
+		repTSIG.Hdr = dns.RR_Header{Name: r.reqTSIG.Hdr.Name, Rrtype: dns.TypeTSIG, Class: dns.ClassANY}
+		repTSIG.Algorithm = r.reqTSIG.Algorithm
+		repTSIG.OrigId = m.MsgHdr.Id
+		m.Extra = append(m.Extra, &repTSIG)
+	}
+
+	return r.ResponseWriter.WriteMsg(m)
+}
+
+func (t *TSIGServer) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dns.Msg) (int, error) {
+	var err error
+	state := request.Request{Req: r, W: w}
+	if z := plugin.Zones(t.Zones).Matches(state.Name()); z == "" {
+		return plugin.NextOrFailure(t.Name(), t.Next, ctx, w, r)
+	}
+
+	var tsigRR = r.IsTsig()
+	rcode := dns.RcodeSuccess
+	if !t.tsigRequired(state.QType()) && tsigRR == nil {
+		return plugin.NextOrFailure(t.Name(), t.Next, ctx, w, r)
+	}
+
+	if tsigRR == nil {
+		log.Debugf("rejecting '%s' request without TSIG\n", dns.TypeToString[state.QType()])
+		rcode = dns.RcodeRefused
+	}
+
+	// wrap the response writer so the response will be TSIG signed.
+	w = &restoreTsigWriter{w, r, tsigRR}
+
+	if err = w.TsigStatus(); err != nil {
+		log.Debugf("TSIG validation failed: %v %v", dns.TypeToString[state.QType()], err)
+		rcode = dns.RcodeNotAuth
+		if err == dns.ErrSecret {
+			tsigRR.Error = dns.RcodeBadKey
+		} else {
+			tsigRR.Error = dns.RcodeBadSig
+		}
+		resp := new(dns.Msg).SetRcode(r, rcode)
+		w.WriteMsg(resp)
+		return dns.RcodeSuccess, nil
+	}
+
+	// strip the TSIG RR. Next, and subsequent plugins will not see the TSIG RRs.
+	if len(r.Extra) > 1 {
+		r.Extra = r.Extra[0 : len(r.Extra)-1]
+	} else {
+		r.Extra = []dns.RR{}
+	}
+
+	if rcode == dns.RcodeSuccess {
+		rcode, err = plugin.NextOrFailure(t.Name(), t.Next, ctx, w, r)
+		if err != nil {
+			fmt.Printf("request handler returned an error: %v\n", err)
+		}
+	}
+	// If not written yet, we have to return the response here to make sure it's TSIG signed.
+	if !plugin.ClientWrite(rcode) {
+		resp := new(dns.Msg).SetRcode(r, rcode)
+		w.WriteMsg(resp)
+	}
+	return dns.RcodeSuccess, nil
+}
+
+func (t *TSIGServer) tsigRequired(qtype uint16) bool {
+	if t.all {
+		return true
+	}
+	if _, ok := t.types[qtype]; ok {
+		return true
+	}
+	return false
+}
+
+const pluginName = "tsig"
diff --git a/plugin/tsig/tsig_test.go b/plugin/tsig/tsig_test.go
new file mode 100644
index 0000000000..ed13313402
--- /dev/null
+++ b/plugin/tsig/tsig_test.go
@@ -0,0 +1,160 @@
+package tsig
+
+import (
+	"context"
+	"fmt"
+	"testing"
+	"time"
+
+	"github.com/miekg/dns"
+
+	"github.com/coredns/coredns/plugin/pkg/dnstest"
+	"github.com/coredns/coredns/plugin/test"
+	"github.com/coredns/coredns/request"
+)
+
+func TestServeDNS(t *testing.T) {
+	cases := []struct{
+		zones []string
+		reqTypes qTypes
+		qType uint16
+		qTsig, all bool
+		expectRcode int
+		expectTsig bool
+		statusError bool
+	}{
+		{
+			zones: []string{"."},
+			all: true,
+			qType: dns.TypeA,
+			qTsig: true,
+			expectRcode: dns.RcodeSuccess,
+			expectTsig: true,
+		},
+		{
+			zones: []string{"."},
+			all: true,
+			qType: dns.TypeA,
+			qTsig: false,
+			expectRcode: dns.RcodeRefused,
+			expectTsig: false,
+		},
+		{
+			zones: []string{"another.domain."},
+			all: true,
+			qType: dns.TypeA,
+			qTsig: false,
+			expectRcode: dns.RcodeSuccess,
+			expectTsig: false,
+		},
+		{
+			zones: []string{"another.domain."},
+			all: true,
+			qType: dns.TypeA,
+			qTsig: true,
+			expectRcode: dns.RcodeSuccess,
+			expectTsig: false,
+		},
+		{
+			zones: []string{"."},
+			reqTypes: qTypes{dns.TypeAXFR: {}},
+			qType: dns.TypeAXFR,
+			qTsig: true,
+			expectRcode: dns.RcodeSuccess,
+			expectTsig: true,
+		},
+		{
+			zones: []string{"."},
+			reqTypes: qTypes{},
+			qType: dns.TypeA,
+			qTsig: false,
+			expectRcode: dns.RcodeSuccess,
+			expectTsig: false,
+		},
+		{
+			zones: []string{"."},
+			reqTypes: qTypes{},
+			qType: dns.TypeA,
+			qTsig: true,
+			expectRcode: dns.RcodeSuccess,
+			expectTsig: true,
+		},
+		{
+			zones: []string{"."},
+			all: true,
+			qType: dns.TypeA,
+			qTsig: true,
+			expectRcode: dns.RcodeNotAuth,
+			expectTsig: true,
+			statusError: true,
+		},
+	}
+
+	for i, tc := range cases {
+		t.Run(fmt.Sprintf("%d", i), func(t *testing.T) {
+			tsig := TSIGServer{
+				Zones: tc.zones,
+				all:   tc.all,
+				types: tc.reqTypes,
+				Next:  testHandler(),
+			}
+
+			ctx := context.TODO()
+
+			var w *dnstest.Recorder
+			if tc.statusError {
+				w = dnstest.NewRecorder(&SigErrWriter{})
+			} else {
+				w = dnstest.NewRecorder(&test.ResponseWriter{})
+			}
+			r := new(dns.Msg)
+			r.SetQuestion("test.example.", tc.qType)
+			if tc.qTsig {
+				r.SetTsig("test.key.", dns.HmacSHA256, 300, time.Now().Unix())
+			}
+
+			_, err := tsig.ServeDNS(ctx, w, r)
+			if err != nil {
+				t.Fatal(err)
+			}
+
+			if w.Msg.Rcode != tc.expectRcode {
+				t.Fatalf("expected rcode %v, got %v", tc.expectTsig, w.Msg.Rcode)
+			}
+
+			if ts := w.Msg.IsTsig(); ts == nil && tc.expectTsig {
+				t.Fatal("expected TSIG in response")
+			}
+			if ts := w.Msg.IsTsig(); ts != nil && !tc.expectTsig {
+				t.Fatal("expected no TSIG in response")
+			}
+		})
+	}
+}
+
+func testHandler() test.HandlerFunc {
+	return func(ctx context.Context, w dns.ResponseWriter, r *dns.Msg) (int, error) {
+		state := request.Request{W: w, Req: r}
+		qname := state.Name()
+		m := new(dns.Msg)
+		rcode := dns.RcodeServerFailure
+		if qname == "test.example." {
+			m.SetReply(r)
+			rr := test.A("test.example.  300  IN  A  1.2.3.48")
+			m.Answer = []dns.RR{rr}
+			m.Authoritative = true
+			rcode = dns.RcodeSuccess
+		}
+		m.SetRcode(r, rcode)
+		w.WriteMsg(m)
+		return rcode, nil
+	}
+}
+
+// a test.ResponseWriter that always returns a TSIG status error
+type SigErrWriter struct {
+	test.ResponseWriter
+}
+
+// TsigStatus always returns an error.
+func (t *SigErrWriter) TsigStatus() error { return dns.ErrSig }
\ No newline at end of file

From b9cf8bd9c63829b96b59bf4dca9f9bdabc271118 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Tue, 2 Nov 2021 16:06:56 -0400
Subject: [PATCH 03/20] tidy

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 core/dnsserver/server.go |  1 -
 plugin/tsig/tsig.go      | 51 ++++++++++++++++++++++------------------
 2 files changed, 28 insertions(+), 24 deletions(-)

diff --git a/core/dnsserver/server.go b/core/dnsserver/server.go
index 1c0d662803..c8ea5704aa 100644
--- a/core/dnsserver/server.go
+++ b/core/dnsserver/server.go
@@ -11,7 +11,6 @@ import (
	"time"

	"github.com/coredns/caddy"
-
	"github.com/coredns/coredns/plugin"
	"github.com/coredns/coredns/plugin/metrics/vars"
	"github.com/coredns/coredns/plugin/pkg/edns"
diff --git a/plugin/tsig/tsig.go b/plugin/tsig/tsig.go
index 53c64e2a99..21652178c3 100644
--- a/plugin/tsig/tsig.go
+++ b/plugin/tsig/tsig.go
@@ -11,6 +11,7 @@ import (
	"github.com/coredns/coredns/request"
 )

+// TSIGServer verifies tsig status and adds tsig to responses
 type TSIGServer struct {
	Zones   []string
	secrets map[string]string // [key-name]secret
@@ -21,31 +22,10 @@ type TSIGServer struct {

 type qTypes map[uint16]struct{}

+// Name implements plugin.Handler
 func (t TSIGServer) Name() string { return pluginName }

-type restoreTsigWriter struct {
-	dns.ResponseWriter
-	req     *dns.Msg  // original request excluding TSIG if it has one
-	reqTSIG *dns.TSIG // original TSIG
-}
-
-func (r *restoreTsigWriter) WriteMsg(m *dns.Msg) error {
-	// Make sure the response has an EDNS OPT RR if the request had it.
-	// Otherwise ScrubWriter would append it *after* TSIG, making it a non-compliant DNS message.
-	state := request.Request{Req: r.req, W: r.ResponseWriter}
-	state.SizeAndDo(m)
-
-	if r.reqTSIG != nil {
-		var repTSIG dns.TSIG
-		repTSIG.Hdr = dns.RR_Header{Name: r.reqTSIG.Hdr.Name, Rrtype: dns.TypeTSIG, Class: dns.ClassANY}
-		repTSIG.Algorithm = r.reqTSIG.Algorithm
-		repTSIG.OrigId = m.MsgHdr.Id
-		m.Extra = append(m.Extra, &repTSIG)
-	}
-
-	return r.ResponseWriter.WriteMsg(m)
-}
-
+// ServeDNS implements plugin.Handler
 func (t *TSIGServer) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dns.Msg) (int, error) {
	var err error
	state := request.Request{Req: r, W: w}
@@ -111,4 +91,29 @@ func (t *TSIGServer) tsigRequired(qtype uint16) bool {
	return false
 }

+// restoreTsigWriter Implement Response Writer, and adds a TSIG RR to a response
+type restoreTsigWriter struct {
+	dns.ResponseWriter
+	req     *dns.Msg  // original request excluding TSIG if it has one
+	reqTSIG *dns.TSIG // original TSIG
+}
+
+// WriteMsg adds a TSIG RR to the response
+func (r *restoreTsigWriter) WriteMsg(m *dns.Msg) error {
+	// Make sure the response has an EDNS OPT RR if the request had it.
+	// Otherwise ScrubWriter would append it *after* TSIG, making it a non-compliant DNS message.
+	state := request.Request{Req: r.req, W: r.ResponseWriter}
+	state.SizeAndDo(m)
+
+	if r.reqTSIG != nil {
+		var repTSIG dns.TSIG
+		repTSIG.Hdr = dns.RR_Header{Name: r.reqTSIG.Hdr.Name, Rrtype: dns.TypeTSIG, Class: dns.ClassANY}
+		repTSIG.Algorithm = r.reqTSIG.Algorithm
+		repTSIG.OrigId = m.MsgHdr.Id
+		m.Extra = append(m.Extra, &repTSIG)
+	}
+
+	return r.ResponseWriter.WriteMsg(m)
+}
+
 const pluginName = "tsig"

From 8b1a067cb83b93396f8eab8b1b1dab9735be26b3 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Wed, 3 Nov 2021 09:45:22 -0400
Subject: [PATCH 04/20] imports

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 core/dnsserver/config.go  | 1 -
 plugin/tsig/setup.go      | 4 ++--
 plugin/tsig/setup_test.go | 1 +
 plugin/tsig/tsig.go       | 4 ++--
 plugin/tsig/tsig_test.go  | 4 ++--
 5 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/core/dnsserver/config.go b/core/dnsserver/config.go
index efee10489f..ce3915e5e1 100644
--- a/core/dnsserver/config.go
+++ b/core/dnsserver/config.go
@@ -6,7 +6,6 @@ import (
	"net/http"

	"github.com/coredns/caddy"
-
	"github.com/coredns/coredns/plugin"
 )

diff --git a/plugin/tsig/setup.go b/plugin/tsig/setup.go
index cfa0fc707a..c5c097a2be 100644
--- a/plugin/tsig/setup.go
+++ b/plugin/tsig/setup.go
@@ -2,10 +2,10 @@ package tsig

 import (
	"github.com/coredns/caddy"
-	"github.com/miekg/dns"
-
	"github.com/coredns/coredns/core/dnsserver"
	"github.com/coredns/coredns/plugin"
+
+	"github.com/miekg/dns"
 )

 func init() {
diff --git a/plugin/tsig/setup_test.go b/plugin/tsig/setup_test.go
index ee49fd3a2c..7ec7fe8f59 100644
--- a/plugin/tsig/setup_test.go
+++ b/plugin/tsig/setup_test.go
@@ -5,6 +5,7 @@ import (
	"testing"

	"github.com/coredns/caddy"
+
	"github.com/miekg/dns"
 )

diff --git a/plugin/tsig/tsig.go b/plugin/tsig/tsig.go
index 21652178c3..b4184fe02d 100644
--- a/plugin/tsig/tsig.go
+++ b/plugin/tsig/tsig.go
@@ -4,11 +4,11 @@ import (
	"context"
	"fmt"

-	"github.com/miekg/dns"
-
	"github.com/coredns/coredns/plugin"
	"github.com/coredns/coredns/plugin/pkg/log"
	"github.com/coredns/coredns/request"
+
+	"github.com/miekg/dns"
 )

 // TSIGServer verifies tsig status and adds tsig to responses
diff --git a/plugin/tsig/tsig_test.go b/plugin/tsig/tsig_test.go
index ed13313402..7770850023 100644
--- a/plugin/tsig/tsig_test.go
+++ b/plugin/tsig/tsig_test.go
@@ -6,11 +6,11 @@ import (
	"testing"
	"time"

-	"github.com/miekg/dns"
-
	"github.com/coredns/coredns/plugin/pkg/dnstest"
	"github.com/coredns/coredns/plugin/test"
	"github.com/coredns/coredns/request"
+
+	"github.com/miekg/dns"
 )

 func TestServeDNS(t *testing.T) {

From dc897d2a6268945faf0da6561249c074a9725cec Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Fri, 12 Nov 2021 14:44:18 -0500
Subject: [PATCH 05/20] add a period to the end of the TsigSecret comment

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 core/dnsserver/config.go | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/dnsserver/config.go b/core/dnsserver/config.go
index ce3915e5e1..d87fecf8fc 100644
--- a/core/dnsserver/config.go
+++ b/core/dnsserver/config.go
@@ -40,7 +40,7 @@ type Config struct {
	// TLSConfig when listening for encrypted connections (gRPC, DNS-over-TLS).
	TLSConfig *tls.Config

-	// TSIG secrets, [name]key
+	// TSIG secrets, [name]key.
	TsigSecret map[string]string

	// Plugin stack.

From df2af532b11b238dc224f91990861b47c89c2ee1 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Wed, 17 Nov 2021 09:53:11 -0500
Subject: [PATCH 06/20] translate time error rcode; copy error code to response

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 plugin/tsig/tsig.go | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/plugin/tsig/tsig.go b/plugin/tsig/tsig.go
index b4184fe02d..019c39213e 100644
--- a/plugin/tsig/tsig.go
+++ b/plugin/tsig/tsig.go
@@ -50,9 +50,12 @@ func (t *TSIGServer) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dns.
	if err = w.TsigStatus(); err != nil {
		log.Debugf("TSIG validation failed: %v %v", dns.TypeToString[state.QType()], err)
		rcode = dns.RcodeNotAuth
-		if err == dns.ErrSecret {
+		switch err {
+		case dns.ErrSecret:
			tsigRR.Error = dns.RcodeBadKey
-		} else {
+		case dns.ErrTime:
+			tsigRR.Error = dns.RcodeBadTime
+		default:
			tsigRR.Error = dns.RcodeBadSig
		}
		resp := new(dns.Msg).SetRcode(r, rcode)
@@ -110,6 +113,7 @@ func (r *restoreTsigWriter) WriteMsg(m *dns.Msg) error {
		repTSIG.Hdr = dns.RR_Header{Name: r.reqTSIG.Hdr.Name, Rrtype: dns.TypeTSIG, Class: dns.ClassANY}
		repTSIG.Algorithm = r.reqTSIG.Algorithm
		repTSIG.OrigId = m.MsgHdr.Id
+		repTSIG.Error = r.reqTSIG.Error
		m.Extra = append(m.Extra, &repTSIG)
	}


From f8bd6b2acfb6cfc14bc426c1c9e8fefdf9233c88 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Wed, 17 Nov 2021 13:48:20 -0500
Subject: [PATCH 07/20] handle bad time error response

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 plugin/tsig/tsig.go | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/plugin/tsig/tsig.go b/plugin/tsig/tsig.go
index 019c39213e..c2737d4c0c 100644
--- a/plugin/tsig/tsig.go
+++ b/plugin/tsig/tsig.go
@@ -1,8 +1,11 @@
 package tsig

 import (
+	"bytes"
	"context"
+	"encoding/binary"
	"fmt"
+	"time"

	"github.com/coredns/coredns/plugin"
	"github.com/coredns/coredns/plugin/pkg/log"
@@ -114,9 +117,23 @@ func (r *restoreTsigWriter) WriteMsg(m *dns.Msg) error {
		repTSIG.Algorithm = r.reqTSIG.Algorithm
		repTSIG.OrigId = m.MsgHdr.Id
		repTSIG.Error = r.reqTSIG.Error
+		if repTSIG.Error == dns.RcodeBadTime {
+			// per RFC 2854 4.5.2. client time goes into TimeSigned, server time in OtherData, OtherLen = 6 ...
+			repTSIG.TimeSigned = r.reqTSIG.TimeSigned
+			nowInt := time.Now().Unix()
+			nowBuf := new(bytes.Buffer)
+			// TimeSigned is networkbyte order. Assuming server time is expected to be the same.
+			binary.Write(nowBuf, binary.BigEndian, nowInt)
+			// truncate to 48 least significant bits (network order 6 rightmost) bytes
+			nowBytes := nowBuf.Bytes()[2:7]
+			repTSIG.OtherData = string(nowBytes)
+			repTSIG.OtherLen = 6
+		}
		m.Extra = append(m.Extra, &repTSIG)
+		// TODO: message truncation case? rfc2845 3.1 where adding TSIG records would cause the message to be truncated.
	}

+
	return r.ResponseWriter.WriteMsg(m)
 }


From 61bd2243bfff0e70d6780dd2c8804c8cf2da7e43 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Tue, 23 Nov 2021 16:25:04 -0500
Subject: [PATCH 08/20] add tsig error case tests; fix error handling

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 plugin/tsig/README.md    |   2 +-
 plugin/tsig/tsig.go      |  36 ++++---
 plugin/tsig/tsig_test.go | 209 +++++++++++++++++++++++++++++----------
 3 files changed, 180 insertions(+), 67 deletions(-)

diff --git a/plugin/tsig/README.md b/plugin/tsig/README.md
index 9d560d0d6c..9cd67a3d02 100644
--- a/plugin/tsig/README.md
+++ b/plugin/tsig/README.md
@@ -18,7 +18,7 @@ tsig [ZONE...] {
 }
 ~~~

-   * **ZONE** - the zones *tsig* will TSIG.  By default, the zones from the server block are used.
+   * **ZONE** - the zones *tsig* will TSIG.  By default, the zones from the server block are used.

    * `secret` **KEY** - specifies a TSIG secret for **NAME** with **KEY**. Use this option more than once
    to define multiple secrets. Secrets are global to the server instance, not just for the enclosing **ZONE**.
diff --git a/plugin/tsig/tsig.go b/plugin/tsig/tsig.go
index c2737d4c0c..2565b0d170 100644
--- a/plugin/tsig/tsig.go
+++ b/plugin/tsig/tsig.go
@@ -1,10 +1,9 @@
 package tsig

 import (
-	"bytes"
	"context"
	"encoding/binary"
-	"fmt"
+	"encoding/hex"
	"time"

	"github.com/coredns/coredns/plugin"
@@ -56,6 +55,9 @@ func (t *TSIGServer) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dns.
		switch err {
		case dns.ErrSecret:
			tsigRR.Error = dns.RcodeBadKey
+			// See RFC-2845: 4.7. Special considerations for forwarding servers
+			// We need to leave the TSIG alone/intact when forwarding.  This can be handled by proper corefile zone
+			// config, i.e. tsig plugin zone should not contain a forwarded zone.
		case dns.ErrTime:
			tsigRR.Error = dns.RcodeBadTime
		default:
@@ -76,7 +78,7 @@ func (t *TSIGServer) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dns.
	if rcode == dns.RcodeSuccess {
		rcode, err = plugin.NextOrFailure(t.Name(), t.Next, ctx, w, r)
		if err != nil {
-			fmt.Printf("request handler returned an error: %v\n", err)
+			log.Errorf("request handler returned an error: %v\n", err)
		}
	}
	// If not written yet, we have to return the response here to make sure it's TSIG signed.
@@ -111,29 +113,33 @@ func (r *restoreTsigWriter) WriteMsg(m *dns.Msg) error {
	state := request.Request{Req: r.req, W: r.ResponseWriter}
	state.SizeAndDo(m)

-	if r.reqTSIG != nil {
-		var repTSIG dns.TSIG
+	repTSIG := m.IsTsig()
+	if r.reqTSIG != nil && repTSIG == nil {
+		repTSIG = new(dns.TSIG)
		repTSIG.Hdr = dns.RR_Header{Name: r.reqTSIG.Hdr.Name, Rrtype: dns.TypeTSIG, Class: dns.ClassANY}
		repTSIG.Algorithm = r.reqTSIG.Algorithm
		repTSIG.OrigId = m.MsgHdr.Id
		repTSIG.Error = r.reqTSIG.Error
+		repTSIG.MAC = r.reqTSIG.MAC
+		repTSIG.MACSize = r.reqTSIG.MACSize
		if repTSIG.Error == dns.RcodeBadTime {
			// per RFC 2854 4.5.2. client time goes into TimeSigned, server time in OtherData, OtherLen = 6 ...
			repTSIG.TimeSigned = r.reqTSIG.TimeSigned
-			nowInt := time.Now().Unix()
-			nowBuf := new(bytes.Buffer)
-			// TimeSigned is networkbyte order. Assuming server time is expected to be the same.
-			binary.Write(nowBuf, binary.BigEndian, nowInt)
-			// truncate to 48 least significant bits (network order 6 rightmost) bytes
-			nowBytes := nowBuf.Bytes()[2:7]
-			repTSIG.OtherData = string(nowBytes)
+			b := make([]byte, 8)
+			// TimeSigned is network byte order.
+			binary.BigEndian.PutUint64(b, uint64(time.Now().Unix()))
+			// truncate to 48 least significant bits (network order 6 rightmost bytes)
+			repTSIG.OtherData = hex.EncodeToString(b[2:])
			repTSIG.OtherLen = 6
		}
-		m.Extra = append(m.Extra, &repTSIG)
-		// TODO: message truncation case? rfc2845 3.1 where adding TSIG records would cause the message to be truncated.
+		// empty MAC for TSIG errors (except BadTime)
+		if repTSIG.Error > 0 && repTSIG.Error != dns.RcodeBadTime {
+			repTSIG.MAC = ""
+			repTSIG.MACSize = 0
+		}
+		m.Extra = append(m.Extra, repTSIG)
	}

-
	return r.ResponseWriter.WriteMsg(m)
 }

diff --git a/plugin/tsig/tsig_test.go b/plugin/tsig/tsig_test.go
index 7770850023..5b71531a9f 100644
--- a/plugin/tsig/tsig_test.go
+++ b/plugin/tsig/tsig_test.go
@@ -14,78 +14,78 @@ import (
 )

 func TestServeDNS(t *testing.T) {
-	cases := []struct{
-		zones []string
-		reqTypes qTypes
-		qType uint16
-		qTsig, all bool
+	cases := []struct {
+		zones       []string
+		reqTypes    qTypes
+		qType       uint16
+		qTsig, all  bool
		expectRcode int
-		expectTsig bool
+		expectTsig  bool
		statusError bool
	}{
		{
-			zones: []string{"."},
-			all: true,
-			qType: dns.TypeA,
-			qTsig: true,
+			zones:       []string{"."},
+			all:         true,
+			qType:       dns.TypeA,
+			qTsig:       true,
			expectRcode: dns.RcodeSuccess,
-			expectTsig: true,
+			expectTsig:  true,
		},
		{
-			zones: []string{"."},
-			all: true,
-			qType: dns.TypeA,
-			qTsig: false,
+			zones:       []string{"."},
+			all:         true,
+			qType:       dns.TypeA,
+			qTsig:       false,
			expectRcode: dns.RcodeRefused,
-			expectTsig: false,
+			expectTsig:  false,
		},
		{
-			zones: []string{"another.domain."},
-			all: true,
-			qType: dns.TypeA,
-			qTsig: false,
+			zones:       []string{"another.domain."},
+			all:         true,
+			qType:       dns.TypeA,
+			qTsig:       false,
			expectRcode: dns.RcodeSuccess,
-			expectTsig: false,
+			expectTsig:  false,
		},
		{
-			zones: []string{"another.domain."},
-			all: true,
-			qType: dns.TypeA,
-			qTsig: true,
+			zones:       []string{"another.domain."},
+			all:         true,
+			qType:       dns.TypeA,
+			qTsig:       true,
			expectRcode: dns.RcodeSuccess,
-			expectTsig: false,
+			expectTsig:  false,
		},
		{
-			zones: []string{"."},
-			reqTypes: qTypes{dns.TypeAXFR: {}},
-			qType: dns.TypeAXFR,
-			qTsig: true,
+			zones:       []string{"."},
+			reqTypes:    qTypes{dns.TypeAXFR: {}},
+			qType:       dns.TypeAXFR,
+			qTsig:       true,
			expectRcode: dns.RcodeSuccess,
-			expectTsig: true,
+			expectTsig:  true,
		},
		{
-			zones: []string{"."},
-			reqTypes: qTypes{},
-			qType: dns.TypeA,
-			qTsig: false,
+			zones:       []string{"."},
+			reqTypes:    qTypes{},
+			qType:       dns.TypeA,
+			qTsig:       false,
			expectRcode: dns.RcodeSuccess,
-			expectTsig: false,
+			expectTsig:  false,
		},
		{
-			zones: []string{"."},
-			reqTypes: qTypes{},
-			qType: dns.TypeA,
-			qTsig: true,
+			zones:       []string{"."},
+			reqTypes:    qTypes{},
+			qType:       dns.TypeA,
+			qTsig:       true,
			expectRcode: dns.RcodeSuccess,
-			expectTsig: true,
+			expectTsig:  true,
		},
		{
-			zones: []string{"."},
-			all: true,
-			qType: dns.TypeA,
-			qTsig: true,
+			zones:       []string{"."},
+			all:         true,
+			qType:       dns.TypeA,
+			qTsig:       true,
			expectRcode: dns.RcodeNotAuth,
-			expectTsig: true,
+			expectTsig:  true,
			statusError: true,
		},
	}
@@ -103,7 +103,7 @@ func TestServeDNS(t *testing.T) {

			var w *dnstest.Recorder
			if tc.statusError {
-				w = dnstest.NewRecorder(&SigErrWriter{})
+				w = dnstest.NewRecorder(&ErrWriter{err: dns.ErrSig})
			} else {
				w = dnstest.NewRecorder(&test.ResponseWriter{})
			}
@@ -119,7 +119,7 @@ func TestServeDNS(t *testing.T) {
			}

			if w.Msg.Rcode != tc.expectRcode {
-				t.Fatalf("expected rcode %v, got %v", tc.expectTsig, w.Msg.Rcode)
+				t.Fatalf("expected rcode %v, got %v", tc.expectRcode, w.Msg.Rcode)
			}

			if ts := w.Msg.IsTsig(); ts == nil && tc.expectTsig {
@@ -132,6 +132,112 @@ func TestServeDNS(t *testing.T) {
	}
 }

+func TestServeDNSTsigErrors(t *testing.T) {
+	clientNow := time.Now().Unix()
+
+	cases := []struct {
+		desc              string
+		tsigErr           error
+		expectRcode       int
+		expectError       int
+		expectMACLength   int
+		expectOtherLength int
+		expectTimeSigned  int64
+	}{
+		{
+			desc:              "Unknown Key",
+			tsigErr:           dns.ErrSecret,
+			expectRcode:       dns.RcodeNotAuth,
+			expectError:       dns.RcodeBadKey,
+			expectMACLength:   0,
+			expectOtherLength: 0,
+			expectTimeSigned:  0,
+		},
+		{
+			desc:              "Bad Signature",
+			tsigErr:           dns.ErrSig,
+			expectRcode:       dns.RcodeNotAuth,
+			expectError:       dns.RcodeBadSig,
+			expectMACLength:   0,
+			expectOtherLength: 0,
+			expectTimeSigned:  0,
+		},
+		{
+			desc:              "Bad Time",
+			tsigErr:           dns.ErrTime,
+			expectRcode:       dns.RcodeNotAuth,
+			expectError:       dns.RcodeBadTime,
+			expectMACLength:   32,
+			expectOtherLength: 6,
+			expectTimeSigned:  clientNow,
+		},
+	}
+
+	tsig := TSIGServer{
+		Zones: []string{"."},
+		all:   true,
+		Next:  testHandler(),
+	}
+
+	for _, tc := range cases {
+		t.Run(tc.desc, func(t *testing.T) {
+			ctx := context.TODO()
+
+			var w *dnstest.Recorder
+
+			w = dnstest.NewRecorder(&ErrWriter{err: tc.tsigErr})
+
+			r := new(dns.Msg)
+			r.SetQuestion("test.example.", dns.TypeA)
+			r.SetTsig("test.key.", dns.HmacSHA256, 300, clientNow)
+
+			// set a fake MAC and Size in request
+			rtsig := r.IsTsig()
+			rtsig.MAC = "0123456789012345678901234567890101234567890123456789012345678901"
+			rtsig.MACSize = 32
+
+			_, err := tsig.ServeDNS(ctx, w, r)
+			if err != nil {
+				t.Fatal(err)
+			}
+
+			if w.Msg.Rcode != tc.expectRcode {
+				t.Fatalf("expected rcode %v, got %v", tc.expectRcode, w.Msg.Rcode)
+			}
+
+			ts := w.Msg.IsTsig()
+
+			if ts == nil {
+				t.Fatal("expected TSIG in response")
+			}
+
+			if int(ts.Error) != tc.expectError {
+				t.Errorf("expected TSIG error code %v, got %v", tc.expectError, ts.Error)
+			}
+
+			if len(ts.MAC)/2 != tc.expectMACLength {
+				t.Errorf("expected MAC of length %v, got %v", tc.expectMACLength, len(ts.MAC))
+			}
+
+			if int(ts.MACSize) != tc.expectMACLength {
+				t.Errorf("expected MACSize %v, got %v", tc.expectMACLength, ts.MACSize)
+			}
+
+			if len(ts.OtherData)/2 != tc.expectOtherLength {
+				t.Errorf("expected Other of length %v, got %v", tc.expectOtherLength, len(ts.OtherData))
+			}
+
+			if int(ts.OtherLen) != tc.expectOtherLength {
+				t.Errorf("expected OtherLen %v, got %v", tc.expectOtherLength, ts.OtherLen)
+			}
+
+			if ts.TimeSigned != uint64(tc.expectTimeSigned) {
+				t.Errorf("expected TimeSigned to be %v, got %v", tc.expectTimeSigned, ts.TimeSigned)
+			}
+		})
+	}
+}
+
 func testHandler() test.HandlerFunc {
	return func(ctx context.Context, w dns.ResponseWriter, r *dns.Msg) (int, error) {
		state := request.Request{W: w, Req: r}
@@ -151,10 +257,11 @@ func testHandler() test.HandlerFunc {
	}
 }

-// a test.ResponseWriter that always returns a TSIG status error
-type SigErrWriter struct {
+// a test.ResponseWriter that always returns err as the TSIG status error
+type ErrWriter struct {
+	err error
	test.ResponseWriter
 }

 // TsigStatus always returns an error.
-func (t *SigErrWriter) TsigStatus() error { return dns.ErrSig }
\ No newline at end of file
+func (t *ErrWriter) TsigStatus() error { return t.err }

From 6ba6781b523db7d55011ff77669500a3c3a12643 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Tue, 30 Nov 2021 14:05:02 -0500
Subject: [PATCH 09/20] fix tests

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 plugin/tsig/tsig.go      |  5 -----
 plugin/tsig/tsig_test.go | 12 ------------
 2 files changed, 17 deletions(-)

diff --git a/plugin/tsig/tsig.go b/plugin/tsig/tsig.go
index 2565b0d170..e3004fd8da 100644
--- a/plugin/tsig/tsig.go
+++ b/plugin/tsig/tsig.go
@@ -132,11 +132,6 @@ func (r *restoreTsigWriter) WriteMsg(m *dns.Msg) error {
			repTSIG.OtherData = hex.EncodeToString(b[2:])
			repTSIG.OtherLen = 6
		}
-		// empty MAC for TSIG errors (except BadTime)
-		if repTSIG.Error > 0 && repTSIG.Error != dns.RcodeBadTime {
-			repTSIG.MAC = ""
-			repTSIG.MACSize = 0
-		}
		m.Extra = append(m.Extra, repTSIG)
	}

diff --git a/plugin/tsig/tsig_test.go b/plugin/tsig/tsig_test.go
index 5b71531a9f..f7ec1fdf1d 100644
--- a/plugin/tsig/tsig_test.go
+++ b/plugin/tsig/tsig_test.go
@@ -140,7 +140,6 @@ func TestServeDNSTsigErrors(t *testing.T) {
		tsigErr           error
		expectRcode       int
		expectError       int
-		expectMACLength   int
		expectOtherLength int
		expectTimeSigned  int64
	}{
@@ -149,7 +148,6 @@ func TestServeDNSTsigErrors(t *testing.T) {
			tsigErr:           dns.ErrSecret,
			expectRcode:       dns.RcodeNotAuth,
			expectError:       dns.RcodeBadKey,
-			expectMACLength:   0,
			expectOtherLength: 0,
			expectTimeSigned:  0,
		},
@@ -158,7 +156,6 @@ func TestServeDNSTsigErrors(t *testing.T) {
			tsigErr:           dns.ErrSig,
			expectRcode:       dns.RcodeNotAuth,
			expectError:       dns.RcodeBadSig,
-			expectMACLength:   0,
			expectOtherLength: 0,
			expectTimeSigned:  0,
		},
@@ -167,7 +164,6 @@ func TestServeDNSTsigErrors(t *testing.T) {
			tsigErr:           dns.ErrTime,
			expectRcode:       dns.RcodeNotAuth,
			expectError:       dns.RcodeBadTime,
-			expectMACLength:   32,
			expectOtherLength: 6,
			expectTimeSigned:  clientNow,
		},
@@ -215,14 +211,6 @@ func TestServeDNSTsigErrors(t *testing.T) {
				t.Errorf("expected TSIG error code %v, got %v", tc.expectError, ts.Error)
			}

-			if len(ts.MAC)/2 != tc.expectMACLength {
-				t.Errorf("expected MAC of length %v, got %v", tc.expectMACLength, len(ts.MAC))
-			}
-
-			if int(ts.MACSize) != tc.expectMACLength {
-				t.Errorf("expected MACSize %v, got %v", tc.expectMACLength, ts.MACSize)
-			}
-
			if len(ts.OtherData)/2 != tc.expectOtherLength {
				t.Errorf("expected Other of length %v, got %v", tc.expectOtherLength, len(ts.OtherData))
			}

From db6cd65c62b366e025ba4bb2cfaff3addb8ab506 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Tue, 30 Nov 2021 16:18:23 -0500
Subject: [PATCH 10/20] copy TSIG secrets to dns.Transfer so it can sign the
 transfer

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 plugin/transfer/setup.go    | 5 ++++-
 plugin/transfer/transfer.go | 4 ++++
 2 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/plugin/transfer/setup.go b/plugin/transfer/setup.go
index 604a269599..4365430dd7 100644
--- a/plugin/transfer/setup.go
+++ b/plugin/transfer/setup.go
@@ -2,6 +2,7 @@ package transfer

 import (
	"github.com/coredns/caddy"
+
	"github.com/coredns/coredns/core/dnsserver"
	"github.com/coredns/coredns/plugin"
	"github.com/coredns/coredns/plugin/pkg/parse"
@@ -28,8 +29,10 @@ func setup(c *caddy.Controller) error {
	})

	c.OnStartup(func() error {
+		config := dnsserver.GetConfig(c)
+		t.tsigSecret = config.TsigSecret
		// find all plugins that implement Transferer and add them to Transferers
-		plugins := dnsserver.GetConfig(c).Handlers()
+		plugins := config.Handlers()
		for _, pl := range plugins {
			tr, ok := pl.(Transferer)
			if !ok {
diff --git a/plugin/transfer/transfer.go b/plugin/transfer/transfer.go
index a9ad211dfe..792dd58cd8 100644
--- a/plugin/transfer/transfer.go
+++ b/plugin/transfer/transfer.go
@@ -18,6 +18,7 @@ var log = clog.NewWithPlugin("transfer")
 type Transfer struct {
	Transferers []Transferer // List of plugins that implement Transferer
	xfrs        []*xfr
+	tsigSecret  map[string]string
	Next        plugin.Handler
 }

@@ -110,6 +111,9 @@ func (t *Transfer) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dns.Ms
	// Send response to client
	ch := make(chan *dns.Envelope)
	tr := new(dns.Transfer)
+	if r.IsTsig() != nil {
+		tr.TsigSecret = t.tsigSecret
+	}
	errCh := make(chan error)
	go func() {
		if err := tr.Out(w, r, ch); err != nil {

From fd0301b1a3dde2087af1cb7382feaa242cbeade3 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Tue, 30 Nov 2021 16:52:14 -0500
Subject: [PATCH 11/20] fix caddy pkg import grouping

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 plugin/transfer/setup.go | 1 -
 1 file changed, 1 deletion(-)

diff --git a/plugin/transfer/setup.go b/plugin/transfer/setup.go
index 4365430dd7..cd7d2091fa 100644
--- a/plugin/transfer/setup.go
+++ b/plugin/transfer/setup.go
@@ -2,7 +2,6 @@ package transfer

 import (
	"github.com/coredns/caddy"
-
	"github.com/coredns/coredns/core/dnsserver"
	"github.com/coredns/coredns/plugin"
	"github.com/coredns/coredns/plugin/pkg/parse"

From 946b9ae4fcfcca8e1f47b54a7e868c7b309b941e Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Fri, 3 Dec 2021 11:29:52 -0500
Subject: [PATCH 12/20] Add Bugs section. Update RFC refs in comments.

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 plugin/tsig/README.md | 41 +++++++++++++++++++++++++++++++++++++++++
 plugin/tsig/tsig.go   |  8 +++-----
 2 files changed, 44 insertions(+), 5 deletions(-)

diff --git a/plugin/tsig/README.md b/plugin/tsig/README.md
index 9cd67a3d02..8217a82c6d 100644
--- a/plugin/tsig/README.md
+++ b/plugin/tsig/README.md
@@ -54,3 +54,44 @@ auth.zone {
   forward . 10.1.0.2
 }
 ```
+
+## Bugs
+
+### Special Considerations for Forwarding Servers (RFC 8945 5.5)
+
+https://datatracker.ietf.org/doc/html/rfc8945#section-5.5
+
+CoreDNS does not implement this section as follows ...
+
+* RFC requirement:
+  > If the name on the TSIG is not
+of a secret that the server shares with the originator, the server
+MUST forward the message unchanged including the TSIG.
+
+  CoreDNS behavior:
+If ths zone of the request matches the _tsig_ plugin zones, then the TSIG record
+is always stripped. But even when the _tsig_ plugin is not involved, the _forward_ plugin
+may alter the message with compression, which would cause validation failure
+at the destination.
+
+
+* RFC requirement:
+  > If the TSIG passes all checks, the forwarding
+server MUST, if possible, include a TSIG of its own to the
+destination or the next forwarder.
+
+  CoreDNS behavior:
+If ths zone of the request matches the _tsig_ plugin zones, _forward_ plugin will
+proxy the request upstream without TSIG.
+
+
+* RFC requirement:
+  > If no transaction security is
+available to the destination and the message is a query, and if the
+corresponding response has the AD flag (see RFC4035) set, the
+forwarder MUST clear the AD flag before adding the TSIG to the
+response and returning the result to the system from which it
+received the query.
+
+  CoreDNS behavior:
+The AD flag is not cleared.
diff --git a/plugin/tsig/tsig.go b/plugin/tsig/tsig.go
index e3004fd8da..7300abc734 100644
--- a/plugin/tsig/tsig.go
+++ b/plugin/tsig/tsig.go
@@ -55,9 +55,6 @@ func (t *TSIGServer) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dns.
		switch err {
		case dns.ErrSecret:
			tsigRR.Error = dns.RcodeBadKey
-			// See RFC-2845: 4.7. Special considerations for forwarding servers
-			// We need to leave the TSIG alone/intact when forwarding.  This can be handled by proper corefile zone
-			// config, i.e. tsig plugin zone should not contain a forwarded zone.
		case dns.ErrTime:
			tsigRR.Error = dns.RcodeBadTime
		default:
@@ -69,6 +66,7 @@ func (t *TSIGServer) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dns.
	}

	// strip the TSIG RR. Next, and subsequent plugins will not see the TSIG RRs.
+	// This violates forwarding cases (RFC 8945 5.5). See README.md Bugs
	if len(r.Extra) > 1 {
		r.Extra = r.Extra[0 : len(r.Extra)-1]
	} else {
@@ -81,7 +79,7 @@ func (t *TSIGServer) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dns.
			log.Errorf("request handler returned an error: %v\n", err)
		}
	}
-	// If not written yet, we have to return the response here to make sure it's TSIG signed.
+	// If the plugin chain result was not an error, restore the TSIG and write the response.
	if !plugin.ClientWrite(rcode) {
		resp := new(dns.Msg).SetRcode(r, rcode)
		w.WriteMsg(resp)
@@ -123,7 +121,7 @@ func (r *restoreTsigWriter) WriteMsg(m *dns.Msg) error {
		repTSIG.MAC = r.reqTSIG.MAC
		repTSIG.MACSize = r.reqTSIG.MACSize
		if repTSIG.Error == dns.RcodeBadTime {
-			// per RFC 2854 4.5.2. client time goes into TimeSigned, server time in OtherData, OtherLen = 6 ...
+			// per RFC 8945 5.2.3. client time goes into TimeSigned, server time in OtherData, OtherLen = 6 ...
			repTSIG.TimeSigned = r.reqTSIG.TimeSigned
			b := make([]byte, 8)
			// TimeSigned is network byte order.

From aaf91e338656b065bb5d55d09f0c8700315d5cb1 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Fri, 3 Dec 2021 13:06:27 -0500
Subject: [PATCH 13/20] Add notify not signed to bugs section; testing tweak

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 plugin/tsig/README.md | 4 ++++
 plugin/tsig/tsig.go   | 7 ++++---
 2 files changed, 8 insertions(+), 3 deletions(-)

diff --git a/plugin/tsig/README.md b/plugin/tsig/README.md
index 8217a82c6d..542f23f7ca 100644
--- a/plugin/tsig/README.md
+++ b/plugin/tsig/README.md
@@ -57,6 +57,10 @@ auth.zone {

 ## Bugs

+### Zone Transfer Notifies
+
+With the transfer plugin, zone transfer notifications from CoreDNS are not TSIG signed.
+
 ### Special Considerations for Forwarding Servers (RFC 8945 5.5)

 https://datatracker.ietf.org/doc/html/rfc8945#section-5.5
diff --git a/plugin/tsig/tsig.go b/plugin/tsig/tsig.go
index 7300abc734..6441c8a6b7 100644
--- a/plugin/tsig/tsig.go
+++ b/plugin/tsig/tsig.go
@@ -49,10 +49,11 @@ func (t *TSIGServer) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dns.
	// wrap the response writer so the response will be TSIG signed.
	w = &restoreTsigWriter{w, r, tsigRR}

-	if err = w.TsigStatus(); err != nil {
-		log.Debugf("TSIG validation failed: %v %v", dns.TypeToString[state.QType()], err)
+	tsigStatus := w.TsigStatus()
+	if tsigStatus != nil {
+		log.Debugf("TSIG validation failed: %v %v", dns.TypeToString[state.QType()], tsigStatus)
		rcode = dns.RcodeNotAuth
-		switch err {
+		switch tsigStatus {
		case dns.ErrSecret:
			tsigRR.Error = dns.RcodeBadKey
		case dns.ErrTime:

From 43bce0f9bcd569d2d87cefaf2211ccf60dc784cf Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Fri, 3 Dec 2021 18:46:31 -0500
Subject: [PATCH 14/20] Add some integration tests

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 test/tsig_test.go | 90 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 90 insertions(+)
 create mode 100644 test/tsig_test.go

diff --git a/test/tsig_test.go b/test/tsig_test.go
new file mode 100644
index 0000000000..1ce369cbec
--- /dev/null
+++ b/test/tsig_test.go
@@ -0,0 +1,90 @@
+package test
+
+import (
+	"testing"
+	"time"
+
+	"github.com/miekg/dns"
+)
+
+var tsigKey = "tsig.key."
+var tsigSecret = "i9M+00yrECfVZG2qCjr4mPpaGim/Bq+IWMiNrLjUO4Y="
+
+var corefile = `.:0 {
+		tsig {
+    		secret ` + tsigKey + ` ` + tsigSecret + `
+		}
+		hosts {
+			1.2.3.4 test
+		}
+	}`
+
+func TestTsig(t *testing.T) {
+	i, udp, _, err := CoreDNSServerAndPorts(corefile)
+	if err != nil {
+		t.Fatalf("Could not get CoreDNS serving instance: %s", err)
+	}
+	defer i.Stop()
+
+	m := new(dns.Msg)
+	m.SetQuestion("test.", dns.TypeA)
+	m.SetTsig(tsigKey, dns.HmacSHA256, 300, time.Now().Unix())
+
+	client := dns.Client{Net: "udp", TsigSecret: map[string]string{tsigKey: tsigSecret}}
+	r, _, err := client.Exchange(m, udp)
+	if err != nil {
+		t.Fatalf("Could not send msg: %s", err)
+	}
+	if r.Rcode != dns.RcodeSuccess {
+		t.Fatalf("Rcode should be dns.RcodeSuccess")
+	}
+	tsig := r.IsTsig()
+	if tsig == nil {
+		t.Fatalf("Respose was not TSIG")
+	}
+	if tsig.Error != dns.RcodeSuccess {
+		t.Fatalf("TSIG Error code should be dns.RcodeSuccess")
+	}
+}
+
+func TestTsigBadKey(t *testing.T) {
+	i, udp, _, err := CoreDNSServerAndPorts(corefile)
+	if err != nil {
+		t.Fatalf("Could not get CoreDNS serving instance: %s", err)
+	}
+	defer i.Stop()
+
+	m := new(dns.Msg)
+	m.SetQuestion("test.", dns.TypeA)
+	m.SetTsig("bad.key.", dns.HmacSHA256, 300, time.Now().Unix())
+
+	client := dns.Client{Net: "udp", TsigSecret: map[string]string{"bad.key.": tsigSecret}}
+	r, _, err := client.Exchange(m, udp)
+
+	if err != dns.ErrAuth {
+		t.Fatalf("Expected \"dns: bad authentication\" error, got: %s", err)
+	}
+	if r.Rcode != dns.RcodeNotAuth {
+		t.Fatalf("Rcode should be dns.RcodeNotAuth")
+	}
+	tsig := r.IsTsig()
+	if tsig == nil {
+		t.Fatalf("Respose was not TSIG")
+	}
+	if tsig.Error != dns.RcodeBadKey {
+		t.Fatalf("TSIG Error code should be dns.RcodeBadKey")
+	}
+	if tsig.MAC != "" {
+		t.Fatalf("TSIG MAC should be empty")
+	}
+	if tsig.MACSize != 0 {
+		t.Fatalf("TSIG MACSize should be 0")
+	}
+	if tsig.TimeSigned != 0 {
+		t.Fatalf("TSIG TimeSigned should be 0")
+	}
+}
+
+// TODO: TestTsigBadSig
+
+// TODO: TestTsigBadTime
\ No newline at end of file

From 134054b48ea0694e0a81cfd839171537a86572f6 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Fri, 3 Dec 2021 18:49:08 -0500
Subject: [PATCH 15/20] Add some integration tests

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 test/tsig_test.go | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/test/tsig_test.go b/test/tsig_test.go
index 1ce369cbec..13e68857d6 100644
--- a/test/tsig_test.go
+++ b/test/tsig_test.go
@@ -87,4 +87,4 @@ func TestTsigBadKey(t *testing.T) {

 // TODO: TestTsigBadSig

-// TODO: TestTsigBadTime
\ No newline at end of file
+// TODO: TestTsigBadTime

From 23dda34309bca772a6a7a527ca6e67c02818b90e Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Mon, 6 Dec 2021 14:35:28 -0500
Subject: [PATCH 16/20] Add BADSIG test

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 test/tsig_test.go | 40 +++++++++++++++++++++++++++++++++++++++-
 1 file changed, 39 insertions(+), 1 deletion(-)

diff --git a/test/tsig_test.go b/test/tsig_test.go
index 13e68857d6..09b817c8a2 100644
--- a/test/tsig_test.go
+++ b/test/tsig_test.go
@@ -58,6 +58,7 @@ func TestTsigBadKey(t *testing.T) {
	m.SetQuestion("test.", dns.TypeA)
	m.SetTsig("bad.key.", dns.HmacSHA256, 300, time.Now().Unix())

+	// rename client key to a key name the server doesnt have
	client := dns.Client{Net: "udp", TsigSecret: map[string]string{"bad.key.": tsigSecret}}
	r, _, err := client.Exchange(m, udp)

@@ -85,6 +86,43 @@ func TestTsigBadKey(t *testing.T) {
	}
 }

-// TODO: TestTsigBadSig
+func TestTsigBadSig(t *testing.T) {
+	i, udp, _, err := CoreDNSServerAndPorts(corefile)
+	if err != nil {
+		t.Fatalf("Could not get CoreDNS serving instance: %s", err)
+	}
+	defer i.Stop()
+
+	m := new(dns.Msg)
+	m.SetQuestion("test.", dns.TypeA)
+	m.SetTsig(tsigKey, dns.HmacSHA256, 300, time.Now().Unix())
+
+	// mangle the client secret so the sig wont match the server sig
+	client := dns.Client{Net: "udp", TsigSecret: map[string]string{tsigKey: "BADSIG00ECfVZG2qCjr4mPpaGim/Bq+IWMiNrLjUO4Y="}}
+	r, _, err := client.Exchange(m, udp)
+
+	if err != dns.ErrAuth {
+		t.Fatalf("Expected \"dns: bad authentication\" error, got: %s", err)
+	}
+	if r.Rcode != dns.RcodeNotAuth {
+		t.Fatalf("Rcode should be dns.RcodeNotAuth")
+	}
+	tsig := r.IsTsig()
+	if tsig == nil {
+		t.Fatalf("Respose was not TSIG")
+	}
+	if tsig.Error != dns.RcodeBadSig {
+		t.Fatalf("TSIG Error code should be dns.RcodeBadSig")
+	}
+	if tsig.MAC != "" {
+		t.Fatalf("TSIG MAC should be empty")
+	}
+	if tsig.MACSize != 0 {
+		t.Fatalf("TSIG MACSize should be 0")
+	}
+	if tsig.TimeSigned != 0 {
+		t.Fatalf("TSIG TimeSigned should be 0")
+	}
+}

 // TODO: TestTsigBadTime

From 9e6f078374c307be2777ba83688fa10f1a3136f5 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Mon, 6 Dec 2021 14:43:31 -0500
Subject: [PATCH 17/20] Add BADTIME test

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 test/tsig_test.go | 40 +++++++++++++++++++++++++++++++++++++++-
 1 file changed, 39 insertions(+), 1 deletion(-)

diff --git a/test/tsig_test.go b/test/tsig_test.go
index 09b817c8a2..19d5d0379a 100644
--- a/test/tsig_test.go
+++ b/test/tsig_test.go
@@ -125,4 +125,42 @@ func TestTsigBadSig(t *testing.T) {
	}
 }

-// TODO: TestTsigBadTime
+func TestTsigBadTime(t *testing.T) {
+	i, udp, _, err := CoreDNSServerAndPorts(corefile)
+	if err != nil {
+		t.Fatalf("Could not get CoreDNS serving instance: %s", err)
+	}
+	defer i.Stop()
+
+	m := new(dns.Msg)
+	m.SetQuestion("test.", dns.TypeA)
+
+	// set time to be older by > fudge seconds
+	m.SetTsig(tsigKey, dns.HmacSHA256, 300, time.Now().Unix()-600)
+
+	client := dns.Client{Net: "udp", TsigSecret: map[string]string{tsigKey: tsigSecret}}
+	r, _, err := client.Exchange(m, udp)
+
+	if err != dns.ErrAuth {
+		t.Fatalf("Expected \"dns: bad authentication\" error, got: %s", err)
+	}
+	if r.Rcode != dns.RcodeNotAuth {
+		t.Fatalf("Rcode should be dns.RcodeNotAuth")
+	}
+	tsig := r.IsTsig()
+	if tsig == nil {
+		t.Fatalf("Respose was not TSIG")
+	}
+	if tsig.Error != dns.RcodeBadTime {
+		t.Fatalf("TSIG Error code should be dns.RcodeBadTime")
+	}
+	if tsig.MAC == "" {
+		t.Fatalf("TSIG MAC should not be empty")
+	}
+	if tsig.MACSize != 32 {
+		t.Fatalf("TSIG MACSize should be 32")
+	}
+	if tsig.TimeSigned == 0 {
+		t.Fatalf("TSIG TimeSigned should not be 0")
+	}
+}

From f186a5eedac3481eac0773b8ea17141371d50ce2 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Tue, 7 Dec 2021 14:36:05 -0500
Subject: [PATCH 18/20] add key file load option

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 plugin/tsig/README.md     |  14 ++++-
 plugin/tsig/setup.go      |  88 ++++++++++++++++++++++++++++-
 plugin/tsig/setup_test.go | 113 ++++++++++++++++++++++++++++++++++++++
 3 files changed, 210 insertions(+), 5 deletions(-)

diff --git a/plugin/tsig/README.md b/plugin/tsig/README.md
index 542f23f7ca..4c5c9dc11e 100644
--- a/plugin/tsig/README.md
+++ b/plugin/tsig/README.md
@@ -14,16 +14,26 @@ responses. It can also require TSIG for certain query types, refusing requests t
 ~~~
 tsig [ZONE...] {
   secret NAME KEY
+  secrets FILE
   require [QTYPE...]
 }
 ~~~

    * **ZONE** - the zones *tsig* will TSIG.  By default, the zones from the server block are used.

-   * `secret` **KEY** - specifies a TSIG secret for **NAME** with **KEY**. Use this option more than once
+   * `secret` **NAME** **KEY** - specifies a TSIG secret for **NAME** with **KEY**. Use this option more than once
    to define multiple secrets. Secrets are global to the server instance, not just for the enclosing **ZONE**.

-   * `require` **QTYPE...** - the query types that must be TSIG'd. Requests of the specified types
+   * `secrets` **FILE** - same as `secret`, but load the secrets from a file. The file may define any number
+     of unique keys, each in the following `named.conf` format:
+     ```cgo
+     key "example." {
+         secret "X28hl0BOfAL5G0jsmJWSacrwn7YRm2f6U5brnzwWEus=";
+     };
+     ```
+     Each key may also specify an `algorithm` e.g. `algorithm hmac-sha256;`, but this is currently ignored by the plugin.
+
+     * `require` **QTYPE...** - the query types that must be TSIG'd. Requests of the specified types
    will be `REFUSED` if they are not signed.`require all` will require requests of all types to be
    signed. `require none` will not require requests any types to be signed. Default behavior is to not require.

diff --git a/plugin/tsig/setup.go b/plugin/tsig/setup.go
index c5c097a2be..4ac44bdf4a 100644
--- a/plugin/tsig/setup.go
+++ b/plugin/tsig/setup.go
@@ -1,6 +1,12 @@
 package tsig

 import (
+	"bufio"
+	"fmt"
+	"io"
+	"os"
+	"strings"
+
	"github.com/coredns/caddy"
	"github.com/coredns/coredns/core/dnsserver"
	"github.com/coredns/coredns/plugin"
@@ -52,7 +58,30 @@ func parse(c *caddy.Controller) (*TSIGServer, error) {
				if len(args) != 2 {
					return nil, c.ArgErr()
				}
-				t.secrets[args[0]] = args[1]
+				k := args[0]
+				if _, exists := t.secrets[k]; exists {
+					return nil, fmt.Errorf("key %q redefined", k)
+				}
+				t.secrets[k] = args[1]
+			case "secrets":
+				args := c.RemainingArgs()
+				if len(args) != 1 {
+					return nil, c.ArgErr()
+				}
+				f, err := os.Open(args[0])
+				if err != nil {
+					return nil, err
+				}
+				secrets, err := parseKeyFile(f)
+				if err != nil {
+					return nil, err
+				}
+				for k, s := range secrets {
+					if _, exists := t.secrets[k]; exists {
+						return nil, fmt.Errorf("key %q redefined", k)
+					}
+					t.secrets[k] = s
+				}
			case "require":
				t.types = qTypes{}
				args := c.RemainingArgs()
@@ -78,8 +107,61 @@ func parse(c *caddy.Controller) (*TSIGServer, error) {
			}
		}
	}
-
	return t, nil
 }

-var defaultQTypes = qTypes{}
\ No newline at end of file
+func parseKeyFile(f io.Reader) (map[string]string, error) {
+	secrets := make(map[string]string)
+	s := bufio.NewScanner(f)
+	for s.Scan() {
+		fields := strings.Fields(s.Text())
+		if len(fields) == 0 {
+			continue
+		}
+		if fields[0] != "key" {
+			return nil, fmt.Errorf("unexpected token %q", fields[0])
+		}
+		if len(fields) < 2 {
+			return nil, fmt.Errorf("expected key name %q", s.Text())
+		}
+		key := strings.Trim(fields[1], "\"{")
+		if len(key) == 0 {
+			return nil, fmt.Errorf("expected key name %q", s.Text())
+		}
+		if _, ok := secrets[key]; ok {
+			return nil, fmt.Errorf("key %q redefined", key)
+		}
+	key:
+		for s.Scan() {
+			fields := strings.Fields(s.Text())
+			if len(fields) == 0 {
+				continue
+			}
+			switch fields[0] {
+			case "algorithm":
+				continue
+			case "secret":
+				if len(fields) < 2 {
+					return nil, fmt.Errorf("expected secret key %q", s.Text())
+				}
+				secret := strings.Trim(fields[1], "\";")
+				if len(secret) == 0 {
+					return nil, fmt.Errorf("expected secret key %q", s.Text())
+				}
+				secrets[key] = secret
+			case "}":
+				fallthrough
+			case "};":
+				break key
+			default:
+				return nil, fmt.Errorf("unexpected token %q", fields[0])
+			}
+		}
+		if _, ok := secrets[key]; !ok {
+			return nil, fmt.Errorf("expected secret for key %q", key)
+		}
+	}
+	return secrets, nil
+}
+
+var defaultQTypes = qTypes{}
diff --git a/plugin/tsig/setup_test.go b/plugin/tsig/setup_test.go
index 7ec7fe8f59..284ddf9e0f 100644
--- a/plugin/tsig/setup_test.go
+++ b/plugin/tsig/setup_test.go
@@ -2,11 +2,14 @@ package tsig

 import (
	"fmt"
+	"strings"
	"testing"

	"github.com/coredns/caddy"
+	"github.com/coredns/coredns/plugin/test"

	"github.com/miekg/dns"
+
 )

 func TestParse(t *testing.T) {
@@ -19,6 +22,17 @@ func TestParse(t *testing.T) {
	for k, s := range secrets {
		secretConfig += fmt.Sprintf("secret %s %s\n", k, s)
	}
+	secretsFile, cleanup, err := test.TempFile(".", `key "name.key." {
+	secret "test-key";
+};
+key "name2.key." {
+	secret "test-key2";
+};`)
+	if err != nil {
+		t.Fatalf("failed to create temp file: %v", err)
+	}
+	defer cleanup()
+
	tests := []struct {
		input           string
		shouldErr       bool
@@ -33,6 +47,12 @@ func TestParse(t *testing.T) {
			expectedQTypes:  defaultQTypes,
			expectedSecrets: secrets,
		},
+		{
+			input:           "tsig {\n secrets " + secretsFile + "\n}",
+			expectedZones:   []string{"."},
+			expectedQTypes:  defaultQTypes,
+			expectedSecrets: secrets,
+		},
		{
			input:           "tsig example.com {\n " + secretConfig + "}",
			expectedZones:   []string{"example.com."},
@@ -134,3 +154,96 @@ func TestParse(t *testing.T) {

	}
 }
+
+func TestParseKeyFile(t *testing.T) {
+	var reader = strings.NewReader(`key "foo" {
+	algorithm hmac-sha256;
+	secret "36eowrtmxceNA3T5AdE+JNUOWFCw3amtcyHACnrDVgQ=";
+};
+key "bar" {
+	algorithm hmac-sha256;
+	secret "X28hl0BOfAL5G0jsmJWSacrwn7YRm2f6U5brnzwWEus=";
+};
+key "baz" {
+	secret "BycDPXSx/5YCD44Q4g5Nd2QNxNRDKwWTXddrU/zpIQM=";
+};`)
+
+	secrets, err := parseKeyFile(reader)
+	if err != nil {
+		t.Fatalf("Unexpected error: %q", err)
+	}
+	expectedSecrets := map[string]string{
+		"foo": "36eowrtmxceNA3T5AdE+JNUOWFCw3amtcyHACnrDVgQ=",
+		"bar": "X28hl0BOfAL5G0jsmJWSacrwn7YRm2f6U5brnzwWEus=",
+		"baz": "BycDPXSx/5YCD44Q4g5Nd2QNxNRDKwWTXddrU/zpIQM=",
+	}
+
+	if len(secrets) != len(expectedSecrets) {
+		t.Fatalf("result has %d keys. expected %d", len(secrets), len(expectedSecrets))
+	}
+
+	for k, sec := range secrets {
+		expectedSec, ok := expectedSecrets[k]
+		if !ok {
+			t.Errorf("unexpected key in result. %q", k)
+			continue
+		}
+		if sec != expectedSec {
+			t.Errorf("incorrect secret in result for key %q. expected %q got %q ", k, expectedSec, sec)
+		}
+	}
+}
+
+func TestParseKeyFileErrors(t *testing.T) {
+	tests := []struct {
+		in  string
+		err string
+	}{
+		{in: `key {`, err: "expected key name \"key {\""},
+		{in: `foo "key" {`, err: "unexpected token \"foo\""},
+		{
+			in: `key "foo" {
+		secret "36eowrtmxceNA3T5AdE+JNUOWFCw3amtcyHACnrDVgQ=";
+	};
+		key "foo" {
+		secret "X28hl0BOfAL5G0jsmJWSacrwn7YRm2f6U5brnzwWEus=";
+	}; `,
+			err: "key \"foo\" redefined",
+		},
+		{in: `key "foo" {
+	schmalgorithm hmac-sha256;`,
+			err: "unexpected token \"schmalgorithm\"",
+		},
+		{
+			in: `key "foo" {
+	schmecret "36eowrtmxceNA3T5AdE+JNUOWFCw3amtcyHACnrDVgQ=";`,
+			err: "unexpected token \"schmecret\"",
+		},
+		{
+			in: `key "foo" {
+	secret`,
+			err: "expected secret key \"\\tsecret\"",
+		},
+		{
+			in: `key "foo" {
+	secret ;`,
+			err: "expected secret key \"\\tsecret ;\"",
+		},
+		{
+			in: `key "foo" {
+	};`,
+			err: "expected secret for key \"foo\"",
+		},
+	}
+	for i, testcase := range tests {
+		_, err := parseKeyFile(strings.NewReader(testcase.in))
+		if err == nil {
+			t.Errorf("Test %d: expected error, got no error", i)
+			continue
+		}
+		if err.Error() != testcase.err {
+			t.Errorf("Test %d: Expected error: %q, got %q", i, testcase.err, err.Error())
+		}
+
+	}
+}

From 6a2ae6279d8502a3d285c6c7fb85f38537228690 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Fri, 10 Dec 2021 15:53:46 -0500
Subject: [PATCH 19/20] normalize key names

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 plugin/tsig/setup.go      |  4 +++-
 plugin/tsig/setup_test.go | 12 ++++++------
 2 files changed, 9 insertions(+), 7 deletions(-)

diff --git a/plugin/tsig/setup.go b/plugin/tsig/setup.go
index 4ac44bdf4a..4fea692fe0 100644
--- a/plugin/tsig/setup.go
+++ b/plugin/tsig/setup.go
@@ -8,6 +8,7 @@ import (
	"strings"

	"github.com/coredns/caddy"
+
	"github.com/coredns/coredns/core/dnsserver"
	"github.com/coredns/coredns/plugin"

@@ -58,7 +59,7 @@ func parse(c *caddy.Controller) (*TSIGServer, error) {
				if len(args) != 2 {
					return nil, c.ArgErr()
				}
-				k := args[0]
+				k := plugin.Name(args[0]).Normalize()
				if _, exists := t.secrets[k]; exists {
					return nil, fmt.Errorf("key %q redefined", k)
				}
@@ -128,6 +129,7 @@ func parseKeyFile(f io.Reader) (map[string]string, error) {
		if len(key) == 0 {
			return nil, fmt.Errorf("expected key name %q", s.Text())
		}
+		key = plugin.Name(key).Normalize()
		if _, ok := secrets[key]; ok {
			return nil, fmt.Errorf("key %q redefined", key)
		}
diff --git a/plugin/tsig/setup_test.go b/plugin/tsig/setup_test.go
index 284ddf9e0f..fcf8d8a023 100644
--- a/plugin/tsig/setup_test.go
+++ b/plugin/tsig/setup_test.go
@@ -6,10 +6,10 @@ import (
	"testing"

	"github.com/coredns/caddy"
+
	"github.com/coredns/coredns/plugin/test"

	"github.com/miekg/dns"
-
 )

 func TestParse(t *testing.T) {
@@ -173,9 +173,9 @@ key "baz" {
		t.Fatalf("Unexpected error: %q", err)
	}
 expectedSecrets := map[string]string{
-		"foo": "36eowrtmxceNA3T5AdE+JNUOWFCw3amtcyHACnrDVgQ=",
-		"bar": "X28hl0BOfAL5G0jsmJWSacrwn7YRm2f6U5brnzwWEus=",
-		"baz": "BycDPXSx/5YCD44Q4g5Nd2QNxNRDKwWTXddrU/zpIQM=",
+		"foo.": "36eowrtmxceNA3T5AdE+JNUOWFCw3amtcyHACnrDVgQ=",
+		"bar.": "X28hl0BOfAL5G0jsmJWSacrwn7YRm2f6U5brnzwWEus=",
+		"baz.": "BycDPXSx/5YCD44Q4g5Nd2QNxNRDKwWTXddrU/zpIQM=",
	}

	if len(secrets) != len(expectedSecrets) {
@@ -208,7 +208,7 @@ func TestParseKeyFileErrors(t *testing.T) {
		key "foo" {
		secret "X28hl0BOfAL5G0jsmJWSacrwn7YRm2f6U5brnzwWEus=";
	}; `,
-			err: "key \"foo\" redefined",
+			err: "key \"foo.\" redefined",
		},
		{in: `key "foo" {
	schmalgorithm hmac-sha256;`,
@@ -232,7 +232,7 @@ func TestParseKeyFileErrors(t *testing.T) {
		{
			in: `key "foo" {
	};`,
-			err: "expected secret for key \"foo\"",
+			err: "expected secret for key \"foo.\"",
		},
	}
	for i, testcase := range tests {

From aeea6279d98b1d07d25368fa42678a5b61a7a4e2 Mon Sep 17 00:00:00 2001
From: Chris O'Haver <cohaver@infoblox.com>
Date: Fri, 7 Jan 2022 10:56:24 -0500
Subject: [PATCH 20/20] import order

Signed-off-by: Chris O'Haver <cohaver@infoblox.com>
---
 plugin/tsig/setup.go      | 1 -
 plugin/tsig/setup_test.go | 1 -
 2 files changed, 2 deletions(-)

diff --git a/plugin/tsig/setup.go b/plugin/tsig/setup.go
index 4fea692fe0..a187a4b4ab 100644
--- a/plugin/tsig/setup.go
+++ b/plugin/tsig/setup.go
@@ -8,7 +8,6 @@ import (
	"strings"

	"github.com/coredns/caddy"
-
	"github.com/coredns/coredns/core/dnsserver"
	"github.com/coredns/coredns/plugin"

diff --git a/plugin/tsig/setup_test.go b/plugin/tsig/setup_test.go
index fcf8d8a023..00966bf09e 100644
--- a/plugin/tsig/setup_test.go
+++ b/plugin/tsig/setup_test.go
@@ -6,7 +6,6 @@ import (
	"testing"

	"github.com/coredns/caddy"
-
	"github.com/coredns/coredns/plugin/test"

	"github.com/miekg/dns"
